# 12971번-숫자 놀이(중국인의 나머지 정리 버전 풀이 필요)

## 문제

- 백준, 실버4, https://www.acmicpc.net/problem/12971
- 풀이 날짜: 2025.4.20., 2025.4.24. 2025.4.25, 2025.4.26
- 풀이 시간
  - 4.20: 21:33~22:01(28분 소요, 포기), 이후 중국인의 나머지 정리 공부
  - 4.24: 11:49~
  - 4.25: 12:22~
  - 4.26: 15:44~17:06
- 알고리즘 분류: 브루트포스, 중국인의 나머지 정리
- 사용 언어: C++

## 문제 해설

고민해봤는데 애초에 내가 해결할 수 있는 문제가 아니라는 느낌이 왔다.

태그 보니까 중국인의 나머지 정리를 필요로 하는 문제였다.

## 수식에 대한 학습

### 중국인의 나머지 정리

https://grok.com/chat/751bb35d-e669-42a9-bf9f-038538bdda22

중국인의 나머지 정리는 다음과 같이 표현됩니다:

**정리**: n1,n2,…,nk n_1, n_2가 서로소(즉, i≠j일 때 $\gcd(n_i, n_j) = 1$ )인 양의 정수들이라고 하자. 그리고 a1,a2,…,ak a_1, a_2가 임의의 정수라고 하자. 그러면 다음 합동식 시스템

$x \equiv a_1 \pmod{n_1}, \quad x \equiv a_2 \pmod{n_2}, \quad \dots, \quad x \equiv a_k \pmod{n_k}$

는 해를 가지며, 이 해는 모듈로 $N = n_1 n_2 \cdots n_k$에 대해 유일하다. 즉, 모든 해는 $x \equiv x_0 \pmod{N}$ 형태로 표현된다(여기서 $x_0$는 특정 해).

**존재성**:

합동식 시스템을 살펴보자.

$$
x \equiv a_i \pmod{n_i} \quad (i=1,2,\ldots,k)
$$

여기서 n₁, n₂, ..., nₖ는 서로소(pairwise coprime)이고, N을 다음과 같이 정의하자:

$$
N = n_1n_2\cdots n_k
$$

각 i에 대해, Nᵢ는 다음과 같이 정의된다:

$$
N_i = \frac{N}{n_i} = n_1\cdots n_{i-1}n_{i+1}\cdots n_k
$$

즉, Nᵢ는 nᵢ를 제외한 모든 모듈러스의 곱이다.

nᵢ와 Nᵢ는 서로소이다(gcd(nᵢ,Nᵢ)=1). 이는 nᵢ가 다른 모든 nⱼ들과 서로소이기 때문이다. 따라서 베주 항등식에 의해, 어떤 정수 yᵢ가 존재하여 다음을 만족한다:

$$
N_iy_i \equiv 1 \pmod{n_i}
$$

여기서 yᵢ는 nᵢ에 대한 Nᵢ의 모듈러 역수이다.

이제 해를 다음과 같이 구성한다:

$$
x = \sum_{i=1}^k a_iN_iy_i
$$

(유일성은 생략)

(원 출처: https://en.wikipedia.org/wiki/Chinese_remainder_theorem, AI 요약)

### 베주 항등식

모듈러 역원을 알기 이전에, 베주 항등식을 이해해야 한다.

> **베주 항등식**
> 적어도 둘 중 하나는 0이 아닌 정수 a, b가 있다. 그리고 a와 b의 최대공약수를 d라고 하자. 이때, 다음 세 명제가 성립한다.
>
> 1. d = ax + by를 만족하는 정수 x, y가 반드시 존재한다.
> 2. d는 정수 x, y에 대하여 ax + by 형태로 표현할 수 있는 가장 작은 자연수이다.
> 3. 정수 x, y에 대하여 ax + by 형태로 표현되는 모든 정수는 d의 배수이다.

코드 단에서 본다면, a, b 중 적어도 하나는 0이 아닐 때, 1번은 $ax+by=gcd(a, b)$를 만족하는 x, y가 반드시 존재함을 의미한다.

### 모듈러 역원

기본적으로 합동식에서는 다음 성질이 성립한다.

- 어떤 수를 곱하거나, 더하고 빼거나, 동일한 자연수 거듭제곱을 해도 동일한 결과가 나온다.
- 덧셈, 뺄셈, 곱셈에 대해 분배 법칙이 성립한다.

그러나 합동식의 양변을 어떤 수로 나누는 것은 성립되지 않는다.

그 대신, 양변을 어떤 정수 a로 나눈다는 것은 어떤 정수 a의 곱셈에 대한 역원을 곱하는 것과 수학적으로 동치이다.

곱셈에 대한 역원이란,

$$
a\times a^{-1} \equiv1 \ (mod\ p)
$$

를 만족하는 정수 $a^{-1}$를 mod p에 대한 a의 곱셈의 역원이라 부른다.

이는 모듈러 역원 또는 모듈러 역수라고도 부른다.

모듈러 역원을 x라 할 때,

$$
\begin{align}
&ax \equiv 1 \ (mod\ p)\\
&ax = pq+1\\
&ax - pq = 1
\end{align}
$$

식 (1)은 식 (2)와 같이 정리 가능하다. pq를 왼쪽으로 넘기면 식 (3)과 같이 되는데, 이는 베주 항등식과 형태가 동일하다.

$$
ax+py=1\ (단,\ y=-q)
$$

베주의 항등식에 다르면, $gcd(a, p) = 1$일 때 ax+py=1을 만족시키는 정수 a, p가 반드시 존재한다.

구하는 것 자체는 순차 탐색으로 찾아도 되지만, 좀 더 효율적으로 구하려면 다른 방법이 필요하다.

1. p가 소수인 경우

p가 소수이고 a, p가 서로소이면, 페르마의 소정리에 의해

$$
a^{p-1} \equiv 1\ (mod\ p)
$$

모듈러 곱셈의 역원의 정의에 의해 식을 다음과 같이 변형할 수 있다.

$$
a \times a ^ {p-2} \equiv 1\ (mod\ p)
$$

그러므로 p가 소수일 때, a와 p가 서로소라면 a의 모듈로 곱셈에 대한 역원은 $a^{p-2}$와 같다.

1. p가 소수가 아닌 경우

모듈로 역원의 정의에 따르면,

$$
ax \equiv 1 \ (mod\ p)
$$

를 만족하는 정수 x를 구해야 한다.

이 식을 변형하면 다음이 된다는 것을 이미 확인하였다.

$$
ax - pq = 1
$$

이 식은 확장 유클리드 알고리즘에서 본 식과 완전히 동일하므로, a와 p에 대한 확장 유클리드 알고리즘으로 정수 x를 구하면 된다.

기타

- a의 모듈러 곱셈에 대한 역원은 유일하지 않다.
  - 하지만 역원들을 p로 나눈 나머지는 항상 유일하다.

https://deepdata.tistory.com/577

### 확장 유클리드 알고리즘

p에 대한 a의 역원은 확장 유클리드 알고리즘으로 ax - pq = 1을 해결하는 x를 구하면 된다.

확장 유클리드 알고리즘이란 유클리드 알고리즘과 같은 결과를 내지만, 베주 항등식

$$
gcd(a, b)=r_k=as_k+bt_k
$$

에서 $s_k$, $t_k$도 함께 구한다는 점에서 차이가 있다.

규칙 자체는 단순하다. 결국 유클리드 알고리즘은 a > b일 때 gcd(a, b) = gcd(b, a - b)임을 이용한다. 이를 활용하여 gcd (a, b) = gcd(b, a % b) (a > b > 0)으로 정리한다.

여기서 한 발 더 나아가, a, b를 이루는 $s_i, t_i$ 계수를 함께 더해나간다. 이를 위해서는 a % b를 구할 때 a에서 b를 얼마나 빼는가, 즉 몫 값 a / b이 필요하게 된다.

그래서 다음과 같이 계산한다.

$$
r_{i+1}=r_{i-1}-q_i r_i\\
s_{i+1}=s_{i-1}-q_i s_i\\
t_{i+1}=t_{i-1}-q_i t_i\\
(단,\ 0\le r_{i+1}<|r_{i}|인\ q_i)
$$

위키백과에서 정리된 바에 따르면 이렇다.

![image.png](attachment:afdc2eb2-e3b9-4555-9474-e3a6b9bd6ddb:image.png)

(https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)

이를 모듈러 역원에 적용하면, $gcd(a, p)=1$일 때 다음 식을 만족하는 x, q를 구하여야 한다.

$$
ax - pq = 1
$$

단, 실제로 필요한 값은 x이므로 q’=-q로 대체하여

$$
ax+pq'=1
$$

을 확장된 유클리드 알고리즘으로 해결하면 된다.

역원에 대한 문제: https://www.acmicpc.net/problem/14565

## 문제 해결

### 브루트포스 방법

도무지 해결 방법을 알 수 없어서 검색해보니, 어차피 해답이 p1*p2*p3 안에 있다 보니, 300^3=27,000,000번의 탐색 내에 해결 가능하다.

### 중국인의 나머지 정리를 사용하는 방법

다음과 같이 서로소일 때에만 답을 정상적으로 구하도록 했더니, 제대로 답이 안 나온다.

```cpp
#include <iostream>

#define MAXIMUM 1000000000

using namespace std;

int modInverse(int a, int m)
{
    int old_x = 1;
    int x = 0;
    int m0 = m;
    int q, r, t;

    while (m != 0)
    {
        q = a / m;
        r = a % m;

        a = m;
        m = r;

        t = x;
        x = old_x - q * x;
        old_x = t;
        // cout << "a, m ->" << a << ", " << m <<
            // "/ old_x, x = " << old_x << ", " << x << "\n";
    }

    // 두 수가 서로소일 때만 역원 반환
    if (a != 1)
        return -1;

    while (old_x < 0)
        old_x += m0;

    // cout << a0 << " * " << old_x << " = " << a0 * old_x << " mod "
        // << m0 << " = " << (a0 * old_x) % m0 << " = 1?\n";
    return old_x;
}

int main()
{
    int p[3], x[3];
    long long n, ansX;

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> p[0] >> p[1] >> p[2] >> x[0] >> x[1] >> x[2];

    n = p[0] * p[1] * p[2];

    if (x[0] == x[1] && x[1] == x[2])
    {
        cout << x[0];
        return 0;
    }

    ansX = 0;
    for (int i = 0; i < 3; i++)
    {
        // 1. ni = n / pi
        // 2. yi는 pi에 대한 ni의 모듈러 역원
        // 즉, (ni * yi) mod pi = 1
        // 3. x = sum(x_i * ni * yi)
        int ni = n / p[i];
        int yi = modInverse(ni, p[i]);
        // cout << p[i] << "에 대한 ni(" << ni << ")의 역원은 " << yi << "\n";
        if (yi == -1)
        {
            cout << "-1";
            return 0;
        }
        // cout << "ansX += " << x[i] << " * " << ni << " * " << yi
            // << " = " << x[i] * ni * yi << "\n";
        ansX += x[i] * ni * yi;
    }

    cout << ansX % n;

    return 0;
}
```

grok에 질의해본 결과, 내가 빠트린 수많은 케이스가 있었다.

나중에 다시 읽어볼 것.

https://grok.com/chat/197758e2-303a-4aee-804c-908bf9ab8188?referrer=website
