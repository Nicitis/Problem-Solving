# 14003번-가장 긴 증가하는 부분 수열 5

## 문제

- 백준, 플래티넘5, https://www.acmicpc.net/problem/14003
- 풀이 날짜: 2025.4.11.
- 풀이 시간:
  - 4.11: 11:00~12:50(1시간 50분)
  - 4.23: 12:05~12:29, comp 해결해야 함. 15:00~15:25(24+25=49분)
- 알고리즘 분류:
- 사용 언어: C++

## 문제 해설

1. 이분 탐색으로 LIS의 길이를 구한다.
2. 역추적으로 LIS의 원소를 탐색한다.
   - 이때 탐색 시에는 마지막에서부터 역으로 순회하면서 lis[i]번째보다 크거나 같은 원소가 나오면 최종 lis[i]로 기록한다.

이와 같은 알고리즘으로 해결해보려고 했는데, 역추적하는 과정에서 원본을 제대로 찾을 수 없었다.

예를 들어,

```cpp
9
10 25 30 40 23 40 50 20 22
정답: 10 25 30 40 50
출력: 10 20 23 40 50
```

위와 같이, 원래 값은 30이어야 하는데, 22로 갱신되는 바람에 23을 발견했을 때 그 값이 그 자리에 있어야 할 값이라고 추론하게 되고, 그로 인해 앞에 22보다 큰 값이 와 있어야 하는데 그걸 발견 못하는 경우가 생길 수 있다.

이는 같은 값이 여러 번 나올 때 위와 같은 문제가 생기는데, 이를 해결하기 위해 같은 값이 나오면 이는 아예 a[i]에 기록하지 않도록 접근했다.

그런데도 문제가 해결이 되지 않는데, 어디에서 문제가 생겼는지 감이 안 잡힌다.

아래는 당시 주석으로 기록한 고민의 흔적이다.

```cpp
문제: lis의 길이는 알겠지만, 정확한 lis가 아니다.
따라서 답을 구한 후에 정답이 되는 lis를 구해줘야 한다.
이때 입력 N <= 100만이므로, O(NlogN) 이하의 알고리즘이 필요하다.

처음에 들어온 입력 a[n]을 저장해놓고, 다시 입력을 순회하여 정답을 탐색해야 한다
방법 1. lis의 인덱스를 저장해놓고, 그 순서대로 순회하자.
단, 몇 개는 재갱신되었을 수도 있으므로 실제로 믿을 수 있는 건 마지막 인덱스뿐이다.
그렇다면, 마지막에서부터 역으로 순회하면서 lis[i]번째보다 크거나 같은 원소가 나오면
최종 lis[i]로 기록한다.
이를 통해 nlogn + n = ~nlogn의 시간에 문제를 해결할 수 있다.

*실제로 가능한가?
각 요소를 갱신할 때 '새 입력보다 같거나 큰 원소가 있다면 대체한다'고 구성했다.
따라서, 갱신되기 전 lis[i]는 현재 lis[i]보다 더 큰 값이었을 것이다.
예제 입력: 10 20 10 30 20 50 25 30 22 40 50
임시 lis: 10 20 22 30 40 50
정답 lis: 10 20 25 30 40 50
50(V) -> 기본 값, lis[5](lis[5]=50)
40(V) -> lis[4]보다 크거나 같으므로 합격(lis[4]=40)
22 -> lis[3] 30보다 작으므로 기각
30(V) -> lis[3] 30보다 크거나 같으므로 합격(lis[3]=30)
25(V) -> lis[2] 22보다 크거나 같으므로 합격(lis[2] = 25)
50 -> lis[1] 20보다 크다. 하지만 다음 값이 되어야 하는 25보다 값이 크다. 따라서 기각.
(lis[i+1] > a[k] >= lis[i]여야 한다.)
20 -> lis[1] 20보다 크거나 같으므로 합격(lis[1] = 20)
10 -> lis[0] 10보다 크거나 같으므로 합격(lis[0] = 10)

즉, 각 요소마다 lis[i] <= a[k] < lis[i+1]을 만족해야 한다.
이 입력을 만족하면 정의에 따라 대체된 원소의 원본임을 예상할 수 있다.

잠깐만.

마지막 인덱스를 갱신하는 거.. 생각해보면 꼭 하나 길이가 늘어날 때가 아니라
마지막 값을 갱신할 때에도 있을 수 있지 않나?
그렇다면 다음과 같은 경우에 오류가 생길 수 있다.

7
4 5 6 1 2 3 -1

출력:
-1 2 3
정답:
1 2 3

*역추적할 때 문제?
아마도 역추적시에 정확하게 추적되지 않는 게 문제가 되는 것 같다.
아마도.. 순서가 이상하게 꼬일 수도 있지 않을까?
예를 들어 원래 값은 30이어야 하는데, 22로 갱신되는 바람에 23을 발견했을 때
그 값이 그 자리에 있어야 할 값이라고 추론하게 되고, 그로 인해 앞에 22보다 큰 값이
와 있어야 하는데 그걸 발견 못하는 경우가 있지 않을까?

입력: 10 25 30 40 23 40 50 20 22
                        ^ last
정답: 10 25 30 40 50
출력: 10 20 23 40 50

이걸 어떻게 해결하지?

문제는 "같은 값이 나와서 순서가 헷깔릴 때"이다.
위에서도 40이 한 번 더 나오지 않았다면 이런 식으로 순서가 꼬일 일이 없었을 것이다.

그렇다면... 같은 값이 나오면 애초에 a[i]에 안 넣었다면 헷깔릴 일이 없었지 않을까?
아예 제외해보자.
```

### 4.23. 추가 풀이

이분 탐색을 사용하면 길이를 구하는 것은 문제가 되지 않았지만, 해당 문제를 풀 때 문제가 되는 건 원래 리스트를 구하는 것이다.

별도의 정보를 기록하지 않으면, 이분 탐색으로 기록한 lis 배열은 실제 가장 긴 증가하는 부분 수열이 아니라 그것으로 갱신하는 과정에서 약간 변형된 형태로 남아 있기 때문에 원 배열을 찾기 어렵다.

그래서 역추적을 할 때 여러 가지 시도를 했는데, 어림짐작으로 원래 값보다 작거나 같은 값이 나오면 이전 요소라고 가정하고 진행했다. 정확한 반례는 모르겠으나, 그로 인해 잘못된 결과가 나오는 것 같다.

그래서 무조건 정상적인 결과만 얻을 수 있도록, 각 수열의 인덱스마다 {증가하는 부분 수열의 이전 idx}를 기록해놓았다. 그러면 마지막 요소에서 이전 인덱스를 계속 추적한다면, 실제 ‘가장 긴 증가하는 부분 수열’의 역순을 얻을 수 있으며, 이를 뒤집어서 출력해주면 끝이다.

이분 탐색에 대한 아이디어는 [12015번-**가장 긴 증가하는 부분 수열 2**](../../03/20250314/12015번-가장%20긴%20증가하는%20부분%20수열%202.md)에 있으니 참고할 것.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/*
4.23.
역추적을 할 때 어림짐작으로 원래 값보다 작거나 같은 값이 나온다는 가정 하에 진행해버려서
잘못된 결과가 나오는 것 같다.
무조건 정상적인 결과만 얻을 수 있도록, 각 수열의 인덱스마다 {증가하는 부분 수열의 이전 idx}를
기록해놓자. 그러면 마지막 요소만 역추적하면 정상적인 결과를 얻을 수 있다.
*/

int a[1000000];
int link[1000000];

int main()
{
    int n, idx;
    vector<int> lis; // element
    vector<int> lisIdx; // idx in a

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;

    // make the longest increase sequence(lis)
    for (int i = 0; i < n; ++i)
    {
        cin >> a[i];
        auto lower = lower_bound(lis.begin(), lis.end(), a[i]);
        idx = lower - lis.begin();
        if (lower != lis.end())
        {
            *lower = a[i];
            lisIdx[idx] = i;
        }
        else
        {
            lis.push_back(a[i]);
            lisIdx.push_back(i);
        }
        // 최초 요소일 경우
        if (idx == 0)
        {
            link[i] = -1;
        }
        // 아닐 경우 이전 노드 연결
        else
        {
            link[i] = lisIdx[idx - 1];
        }
    }

    // 최장 길이 lis 찾기
    int cur = lisIdx[lis.size() - 1];
    for (int i = lis.size() - 1; i >= 0; i--)
    {
        lis[i] = a[cur];
        cur = link[cur];
    }

    cout << lis.size() << "\n";
    for (int i : lis)
    {
        cout << i << " ";
    }

    cout << "\n";

    return 0;
}
```

### 다른 접근법

다만 다른 사람의 풀이를 보니, a 배열과 같은 크기로 배열 하나를 더 선언하면 된다고 한다. LIS에서의 인덱스를 표시하는 배열인데, 그러면 a 배열을 역순으로 조회할 때 현재 찾는 인덱스에 해당하는 요소만 출력하는 것으로 해결된다는 것이다.

마지막 요소(k번째)의 a에서의 인덱스 idx 하나만 안다면, a 배열에 대해 idx로부터 역순으로 조사하면 된다. 이때, a[idx]보다 작은 요소만 탐색한다면 적절하지 않은 대상을 찾게 될 수도 있다. 따라서, a[idx], a[idx-1], a[idx-2], …와 같이 a를 역순으로 탐색하되, lis에서 (k-1)번째인 요소, lis에서 (k-2)번째인 요소, …, lis에서 1번째인 요소를 순차적으로 기록하면 된다.

**정리**

정리하자면, 이분탐색 과정에서 a의 각 요소마다 lis에 넣을 수 있는지 찾아볼 것이다. 이때 a의 각 요소는 lis를 대체해나감과 동시에, 몇 번째 요소를 대체하려 했는지 LIS 인덱스 배열에 기록한다.

나중에 역추적할 경우, lis의 마지막 요소부터 다시 셀 것이다. 이때 a에서 역추적 시에 LIS 인덱스 배열도 함께 보면서, 실제 4번째 요소를 대체하려 했던 요소인지, 3번째 요소를 대체하려 했던 요소인지 확인해보며 진행하게 된다. 이렇게 하면 분명히 ‘해당 인덱스에 기록되었던 값’을 찾을 수 있다.

이렇게 되면 O(N)의 추가 시간으로 문제를 해결할 수 있다.
