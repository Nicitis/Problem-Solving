# 25487번-단순한 문제 (Large)

## 문제

- 백준, 실버 3, https://www.acmicpc.net/problem/25487
- 풀이 날짜: 2025.4.7.
- 풀이 시간: 17:00~17:56(질문 게시판, 태그 확인)
- 알고리즘 분류: 수학, 정수론
- 사용 언어: C++

## 문제 해설

참 허무한 문제다.

해당 문제는 살펴보자면, T≤60만의 테스트 케이스 범위에서 (a, b, c) 세 개 숫자에서 1≤a,b,c≤10만의 범위를 처리해야 한다.

따라서 각 테스트 케이스별로 시간 제한 2.4초/60만 = 0.000004초로, 잘해봐야 평균 logN의 시간 내에 해결해야 한다.

logN의 시간에 해결하는 방법을 찾는 것은 어려우므로, 상수 시간으로 해결할 수 있는 방법을 고려해보는 것도 방법이 된다.

즉, 각 문제는 아주 간단한 규칙으로 해결 가능하다고 유추할 수 있다.

테스트 케이스를 스스로 세워보면서 규칙성을 찾는 문제이다.

테스트 케이스 1, 2, 3에서는 (1,1,1)만이 정답이다.

테스트 케이스 3, 2, 4에서는 2개, (1,1,1)과 (2,2,2)만이 답이 된다.

여기까지 하면 약간의 규칙을 알 수 있는데, 확신을 위해 다른 테스트 케이스도 살펴보자.

테스트 케이스 5, 6, 7에서는 5개, (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5)가 정답이다.

이렇게 되는 이유는 어떤 수가 다른 수가 된다 치면 어떤 수는 반드시 n < m이어야 한다.

그런데 n mod m (n < m)인 케이스에서는 반드시 나머지가 n이 되는데, 어떤 수 k mod n이 n이 되도록 수를 만들 수는 없다.

그러면 순환으로 세 개의 연산의 나머지가 동일하도록 유도할 수가 없게 된다.

실제 테스트 케이스를 돌려보다 보면, 세 숫자가 동일해야만 서로를 서로로 나눈 나머지가 동일하게 된다.

이러한 점에 따라, 세 개의 수가 동일한 3-순서쌍의 개수를 구하는 문제로 요약할 수 있고, 그 정답은 min(a, b, c)가 된다.

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int t, a, b, c;

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> t;

    for (int i = 0; i < t; i++)
    {
        cin >> a >> b >> c;

        cout << min({a, b, c}) << '\n';
    }

    return 0;
}
```
