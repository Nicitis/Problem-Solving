# 백준 1402번-아무래도이문제는A번난이도인것같다

## 문제

- 백준, 실버 5, [문제 링크](https://www.acmicpc.net/problem/1402)
- 풀이 날짜: 2025.04.29
- 풀이 시간: 14:56~15:17 (21분)
- 알고리즘 분류: 수학
- 사용 언어: C++

## 문제 해설

고민은 정말 많이 했는데, 알고 보니 정답이 어처구니 없는 문제.

가장 먼저 생각한 방법은 완전 탐색으로 A=a1*a2*...*an으로 인수분해하는 방법이었다.
A=a1*a2*...*an으로 인수분해할 때, 인수 a는 정수라는 것 외에 조건이 없으므로 1~sqrt(A)까지의 수로 나누어보면서 나누어 떨어지는 인수 a를 찾는 것이다.
같은 숫자로 여러 번 나눠볼 수 있고 중복으로 같은 조합을 세는 경우를 없애기 위해, 이전 숫자 prev가 주어질 때 prev~sqrt(n)까지의 수로 수를 나눠볼 수 있을 듯했다. 나눠지는 자연수 i를 찾으면, i 또는 -i로 나누면 되었다.

그런데 여기서 생각해보면, A에서 B로 바꾸어지는지만 생각하면 되었다.
A에서 B로 바꾼다 할 때 세 가지 경우로 나누어 생각할 수 있다.

(i) A<B일 때,
A에 1을 (B-A)번 곱하면 1*1*1*...*A를 하여 B를 만들 수 있다. 따라서, 이 경우 언제나 참이 된다.
(ii) A=B일 때,
A = A로 두면, B=A이므로 인자의 합이 B가 되어 언제나 참이 된다.
(iii) A>B일 때,
가장 먼저 생각한 방법은 A에서 2 이상의 인수를 구해보는 것이다. 여기서 생각할 수 있는 특징은, 그 인수의 합 total=a1+a2+...+an이 B보다 작다면 A에 1을 계속 곱해서 total을 B로 만들 수 있다.

예제 입력에서 6 = 2 _ 3 → 2 + 3 =5이므로 참이다.
그런데 반대로, (-2)+(-3)=-1 <= 5이므로 위 규칙(인수의 합이 B보다 작을 경우 참)에 의해 참이 된다.
그런데 인수의 합을 가장 작게 만들 방법이 무엇일까?
생각해보면, (-1)을 두 번 곱하면 무조건 1이 된다. 그러면, A가 어떤 값이든 인수의 합은 B보다 작아질 방법이 존재한다.
예를 들어 10을 -100으로 바꾸려면, (-1) _ (-1)을 계속 수행하다 보면
A = ((-1)_(-1))^100 _ 10 = 10이고, 인수의 합 (-1)\*200+10 < -100이므로 이것도 정답이 참이 된다.
즉, A>B일 때에도 참이 된다.

모든 경우에 참이 되므로, 해당 문제의 정답은 언제나 참, 즉 ‘yes’가 된다. 참 어처구니 없는 문제다.

```cpp
#include <iostream>

using namespace std;

int main()
{
    int t, a, b;

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> t;

    while(t--)
    {
        cin >> a >> b;

        cout << "yes\n";
    }

    return 0;
}
```
