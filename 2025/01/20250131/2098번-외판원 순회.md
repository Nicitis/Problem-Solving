# 2098번-외판원 순회

## 문제

- 백준, 골드 1, https://www.acmicpc.net/problem/2098
- 풀이 날짜: 2025.1.31.
- 풀이 시간: 11:39~12:07
- 알고리즘 분류: 비트마스킹, 비트필드를 이용한 다이나믹 프로그래밍, 외판원 순회 문제
- 사용 언어: C++

## 문제 해설

이전 풀이: 1월 27일, 28일

해당 문제는 그래프 순회 문제처럼 보이지만, 중복을 피하기 위해서 **다이나믹 프로그래밍**으로 접근해야 하는 문제이다.

모든 방문은 고유한 것처럼 보이지만, 중복되는 상황이 많이 존재한다.

예를 들어, 5번 도시를 방문한 뒤에 1→2→3→4번 도시를 방문하는 것과 6번 도시를 방문한 뒤에 1→2→3→4번 도시를 방문하는 비용은 다르다. 하지만 1→2→3→4번 도시를 방문하는 비용 자체는 동일하다. 따라서 이러한 중복되는 부분을 메모이제이션(Memoization)으로 저장할 필요가 있다.

그런데 그렇다고 일반 다이나믹 프로그래밍 문제로 접근하기에는, 고려해야 할 것이 많이 있다. 해당 문제는 모든 도시를 순회하면서 각 도시에 단 한 번씩만 방문해야 한다는 조건이 있다. 즉, 해당 도시를 방문했다면 다시 방문하지 않도록 방문 상태를 기록해야 한다. 그런데 일반 DP에서는 마지막에 어느 도시를 방문했는지는 알 수 있어도, 지금까지 방문한 모든 도시를 기록할 수는 없다. 도시를 방문한 순서를 알기 위해 트리 형태로 [16][16][16]…[16] 형태의 길이 16짜리 경로를 기록하려고 하면 $16^{16}$의 메모리가 필요해서 기록이 불가능한 수준이 된다.

이를 해결하기 위해 **비트필드**를 이용한 상태가 필요하다. 0번 도시부터 (N-1)번 도시가 있다 할 때, 1번 도시, 2번 도시를 방문했다면 방문 상태는 0000 0000 0000 0110(우측부터 0번)과 같이 기록할 수 있다. 이렇게 하면 (1<<16) = $2^{16}=65,536$개의 상태만 있으면 되고, 가장 처음 방문한 도시 K가 어딘지 알 수 있다면 비용을 계산할 수 있다.

현재 방문 상태가 visit일 때 임의의 도시 V에서 인접한 도시 K로 방문하는 비용은 다음과 같이 정의할 수 있다.

**f(V, visit)**을 “도시 V를 가장 먼저 방문하였고 방문 상태가 visit과 같을 때, 나머지 도시를 순회하는 최소 비용”이라 정의하자. 그러면

$$
f(V, visit) = min_{인접한\ 도시\ k}\{f(V, visit), f(V, visit|(1<<k))+w(i, j)\}
$$

이다(단, w(i, j)는 도시 i에서 도시 j로 이동하는 비용).

이때 시작할 도시를 어디로 할지 정해야 하는데, 어느 도시를 시작 도시로 삼아도 결과가 동일하다. 왜냐하면 원형 순열 A → B → C → A는 순서를 한 칸씩 미루면 B → C → A → B로 같은 결과를 얻을 수 있기 때문이다. 같은 도시로 돌아와야 하기 때문에 어느 도시에서 시작하든 결과는 같다. 그러니 시작 도시를 0이라 하자.

(여기서, 시작 도시와 ‘가장 먼저 방문한 도시’는 다른 말이다.

시작 도시는 모든 순회의 시작이다. 반면, 가장 먼저 방문한 도시는 현재 방문한 도시 리스트 중에서 가장 처음 방문한 도시다.

0번 도시를 시작 도시로 했다면, 1번 도시부터 시작하여 0번 도시로 돌아오는 최소 비용, 2번 도시에서 0번 도시로 돌아오는 최소 비용, …, i번 도시에서 0번 도시로 돌아오는 최소 비용을 모두 구할 것이다. 이때 i번 도시는 i번 도시부터 0번 도시까지 돌아올 때까지 방문하는 과정에서 ‘가장 먼저 방문한 도시’에 해당한다.

하지만 실제 시작 도시는 0번이다. 앞에서 각 도시를 시작점으로 해서 0번 도시로 돌아오는 비용을 구한 후에, 실제 시작 도시인 0번에서 각 도시들로 이동하는 비용을 추가로 더하는 식으로 계산한다. 말이 어렵지만, DFS 방식이라 생각하면 된다.)

만약 모든 도시를 방문했다면, 시작한 도시로 돌아와야 하므로, 다음과 같이 정의한다.

$$
f(V, 1111...1111) =f(V, (1 << N) - 1) = w(v, 0) \\\text{(단, w(v, 0)이 0이 아닐 때)}
$$

조건으로 w(v, 0)이 0이 아닐 때로 정의했는데, 0일 경우 아예 연결되지 않아 이동이 불가하다. 따라서 그 경우엔 최대값 INF를 반환하도록 한다.

이때 최소 비용 함수를 f로 했는데, 이 값은 dp에 저장하도록 했다. 인자는 위에 적은 거과 마찬가지로, dp(처음 방문한 도시, 방문한 도시 상태)로 기록하도록 한다.

비트필드를 이용한 다이나믹 프로그래밍은 Bottom-up 방식으로 모든 비트필드를 순서대로 순회하는 방식과 Top-down으로 DFS 순회를 하는 방법이 있다. 여기에서는 DFS 순회를 하는 식으로 구현했다.

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

// 최댓값과 시작 도시
#define INF 987654321
#define START_CITY 0

using namespace std;

int dp[16][(1 << 16)]; // DP
int w[16][16]; // 도시별 가중치

int N;

// 현재 상태 visit에 대하여,
// 도시 before에서 출발하여 아직 방문하지 않은 도시를 모두 순회한 뒤
// 0번으로 돌아오는 비용을 계산
int dfs(int before, int visit)
{
    int result = INF;

    // 이미 방문하여 최소 비용을 계산했다면 이를 그대로 사용
    if (dp[before][visit] != -1)
        return dp[before][visit];

    // 모두 방문했다면, 0번 도시로 돌아오는 비용을 계산한다.
    if (visit == (1 << N) - 1)
    {
        // 비용이 0이 아닐 때만 계산
        if (w[before][START_CITY] != 0)
            result = w[before][START_CITY];
        dp[before][START_CITY] = result;
        return result;
    }

    // 방문하지 않은 도시를 순회하는 최소 비용을 DFS로 계산
    for (int i = 0; i < N; i++)
    {
        // 이동이 불가능한 경우는 제외
        if (w[before][i] == 0)
            continue;
        // 해당 도시 i에 방문하지 않았다면 방문 시도
        if (!(visit & (1 << i)))
        {
            // 해당 도시에 방문하는 최소 비용 계산
            // [내 순회 비용] = [이웃 도시의 순회 비용] + [이웃으로 가는 비용]
            result = min(result, w[before][i] + dfs(i, visit | (1 << i)));
        }
    }
    dp[before][visit] = result;
    return result;
}

int main()
{
    int answer = INF;

    cin >> N;

    // 방문하지 않은 도시는 -1로 표시
    memset(dp, -1, sizeof(dp));

    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            cin >> w[i][j];

    // 시작 도시 0번부터 순회를 시작하기
    answer = dfs(START_CITY, (1 << START_CITY));

    cout << answer << '\n';

    return 0;
}
```
