# 16953번-A→B

## 문제

- 백준, 실버2, [16953번: A → B](https://www.acmicpc.net/problem/16953)
- 풀이 날짜: 2025.1.10
- 풀이 시간: 19:28~19:29(11분)
- 알고리즘 분류: 그리디 알고리즘, 너비 우선 탐색
- 사용 언어: C++

## 문제 해설

해당 문제는 두 방법으로 접근할 수 있다.

1. 시작값 A로부터 목표값 B까지 증가시키는 모든 경로를 탐색하는 방법 → 너비우선탐색
2. 목표값 B에서 A로 감소시키기(그리디 알고리즘)

A에서 B로 증가시키는 방법은 최단경로를 탐색하는 문제이다. 모든 상태에서 두 가지 경로가 존재하므로, 그중에서 너비우선탐색으로 최단 경로를 찾아야 한다.

반면 감소시키는 방법을 보면 각 값에 두 가지 접근 방법이 있으므로 이 둘을 탐색해야 한다. 다만 여기에서 생각해보면, 2를 곱하는 방법과 뒤에 1을 붙이는 방법은 공존할 수 없다.

우선, 2를 곱하게 되면 무조건 현재 값은 짝수가 된다.

또 뒤에 1을 붙이면 현재 값은 10으로 나누었을 때 나머지가 1이 붙어 있으며 이 경우 반드시 홀수이므로 2를 곱하는 경로와 겹치지 않는다.

따라서 찾을 수 있는 경로는 단 하나로 무조건 최단경로를 찾을 수 있다. 탐색에 필요한 시간 복잡도는 최악의 경우 2를 곱한다고 할 때 O(logB)의 시간이 걸리게 될 것이다. 즉, 1번보다 2번 방법이 더 효율적이므로 해당 방법을 택하도록 한다.

이를 구현하면 다음과 같다.

```cpp
#include <cstdio>

int main()
{
    int A, B, op = 1;

    scanf("%d %d", &A, &B);

    while (B > A)
    {
        if (B % 10 == 1)
            B /= 10;
        else if (B % 2 == 0)
            B = B >> 1;
        else
            break;
        op++;
    }
    if (A != B)
        printf("-1\n");
    else
        printf("%d\n", op);

    return 0;
}
```