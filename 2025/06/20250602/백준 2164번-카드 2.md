# 백준 2164번-카드 2

## 문제

- 백준, 실버 4, [문제 링크](https://www.acmicpc.net/problem/2164 "https://www.acmicpc.net/problem/2164")
- 풀이 날짜: 2025.06.02
- 풀이 시간: 22:09~22:24(15분), 최종 22:52
- 알고리즘 분류: 자료구조, 큐, 수학
- 사용 언어: C++

## 문제 해설

N장 카드의 카드가 주어지고, 1이 위, N이 가장 아래이므로 작을수록 위에 있다.

이후 한 장 남을 때까지 다음을 반복한다.

- 제일 위에 버림
- 그 후 제일 위 카드를 제일 아래 밑으로

### 아이디어 1 큐 사용

처음 든 생각으로, 큐를 쓰면 되지 않을까? 라고 생각했다.

예시를 보자.

---

N=1

1 -> 1

---

N=2

12 -> 2

---

N=3

123 -> 23 -> 32 -> 2

---

N=4 (4번째 자리가 정답)

1234 -> 234 -> 342 -> 42 -> 24 -> 4

---

N=5 (2번째 자리가 정답)

12345 -> 2345 -> 3452 -> 452 -> 524 -> 24 -> 42 -> 2

---

N=6 -> 4번째 자리가 정답

123456 -> 23456 -> 34562 -> 4562 -> 5624

-> 624 -> 246 -> 46 ->64 -> 4

---

N=7 -> 6번째 자리

1234567

-> 234567 -> 345672

-> 45672 -> 56724

-> 6724 -> 7246

-> 246 -> 462

-> 62 -> 26

-> 6

---

여기까지 보았을 때, 패턴은 1 2 2 4 2 4 6 이렇게 나타났다.

여기까지 보았을 땐 규칙성을 찾을 수가 없었다.

앞의 요소를 뒤로 옮긴다는 점에서 queue를 이용해 간단히 구현할 수 있다.

또한, 주어진 동작을 그대로 수행하면, 시간 복잡도는 N에 비례한다(하나의 값을 제거하고 하나의 값을 뒤로 옮길 때 카드의 크기가 1씩 줄어드므로).

그런데 $N \le 500,000$이므로 queue로 구현해도 충분히 1초의 시간 안에 해결할 수 있다고 보았다.

```cpp
#include <iostream>
#include <queue>

using namespace std;

int main()
{
    int n;

    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;

    queue<int> q;
    for (int i = 1; i <= n; i++)
    {
        q.push(i);
    }

    while (q.size() > 1)
    {
        q.pop();
        int top = q.front();
        q.pop();
        q.push(top);
    }

    cout << q.front();

    return 0;
}
```

### 개선된 방법: 규칙성으로 해결하기

그런데 시간이 조금 느렸다. 그래서 다른 방법을 찾아보았다.

계속 규칙성을 찾아보자.

---

N=8 ->

12345678 -> 2345678 -> 3456782

-> N=7의 정답 -> 8

---

N=9 ->

123456789 -> 3번째부터, 8번째 자리 -> 1?

34567892의 8번째 자리 -> 2

---

N=10 ->

1234567890 -> 345678902의 2번째 자리 -> 4

---

N=11 -> 예상 6

1234578901 -> 345678902의 4번째 자리 -> 6

---

N=12 (예상 8)

123456789012 -> 34567890121의 6번째 자리 -> 8

---

N=16

1234567890123456 -> 345678901234562의 14번째 -> 16

---

패턴 1 / 2 / 2 4 / 2 4 6 8 / 2 4 6 8 10 12 14 16 /

---

N=16까지 진행해 본 결과, 값이 순서대로 올라가는 수열 형태로 나타나는 것을 볼 수 있다.

규칙화하자면, N=7 -> (7 - 4) \* (2) = 6이다.

일반화하면, N=k일 때, $2^t<k$인 가장 큰 $2^t$에 대해, 정답은 $f(k) = k - 2^t * 2$로 정의할 수 있다.

단, N=1일 땐 1을 출력해야 한다.

이렇게 구현하면 $2^t<k$인 가장 큰 $2^t$를 구하는 데에 ~logN의 시간이 소요된다.

이후 f(k)를 구하는 데 곱하기 연산 및 뺄셈 연산이 필요하므로 ~1, 즉 상수 시간이 소요된다.

즉, ~logN의 시간에 문제를 해결 가능하다.

```cpp
#include <iostream>

using namespace std;

int main()
{
    int n;

    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;

    if (n == 1)
    {
        cout << "1";
        return 0;
    }

    int i = 1;
    int result;
    while (n > (i << 1))
    {
        i <<= 1;
    }
    cout << (n - i) * 2;

    return 0;
}
```
