# 백준 1094번-막대기

## 문제

- 백준, 실버 5, [문제 링크](https://www.acmicpc.net/problem/1094 "https://www.acmicpc.net/problem/1094")
- 풀이 날짜: 2025.05.10
- 풀이 시간: 00:15~00:25(10분)
- 알고리즘 분류: 수학, 비트마스킹
- 사용 언어: C++

## 문제 해설

처음 생각했을 땐 이분 탐색 문제인 거 같았다.

가장 짧은 막대는 언제나 길이가 64 → 32 → 16 → 8 → 4 → 2 → 1 순으로 흘러간다.

만약 가장 짧은 막대를 나누고 나서 하나를 버리더라도 남아 있는 막대의 길이의 합이 X보다 크거나 같다면, 하나를 버린다고 한다.

이 점을 생각하면, 막대를 버릴 때(합이 X보다 클 때) 막대의 개수는 그대로이고, 막대를 버리지 않을 때(합이 X보다 작을 때) 막대의 개수가 하나 더 더해진다.

그러나 여기서 한 번 더 생각해보면, 언제나 같은 길이의 막대는 하나만 존재하게 되어 있다.

64인 막대는 최대 1개, 32인 막대도 최대 1개이다. 나머지도 마찬가지인데, 어차피 어떤 막대, 예를 들어 8이라는 막대가 두 개가 되어버린 채로 합이 X가 되어 끝나버린다면 굳이 그 값을 나눌 필요가 없었을 것이다.

그렇다면, 그냥 1, 2, 4, 8, 16, 32, 64인 길이의 막대를 하나씩 선택해서 X라는 값을 만들기 위해 몇 개의 값이 필요한지 계산하면 되지 않을까?

X를 2의 거듭제곱으로 표현해보자.

23 = 16 + 4 + 2 + 1이므로 23은 네 개의 막대가 필요하다.

32 = 32이므로 1개의 막대가 필요하다.

64 =  64이므로 1개의 막대가 필요하다.

48 = 32 + 16이므로 2개의 막대가 필요하다.

잘 보면 X가 64 이하의 자연수일 때(문제의 조건) 실제로 잘 맞아 떨어짐을 알 수 있다.

따라서, 단순히 X를 2진수 비트화해서, 1인 비트의 개수를 구하면 된다.

```cpp
#include <iostream>

using namespace std;

int main()
{
    int x, n = 0;

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> x;

    while (x)
    {
        if ((x & 0x1) == 1)
            n++;
        x >>= 1;
    }

    cout << n;

    return 0;
}
```
