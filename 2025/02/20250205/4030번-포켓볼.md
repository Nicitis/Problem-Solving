# 4030번-포켓볼

## 문제

- 백준, 실버2, https://www.acmicpc.net/problem/4030
- 풀이 날짜: 2025.2.5.
- 풀이 시간: 10:34~11:27, GPT 사용, 11:36 해결 (1시간 2분)
- 알고리즘 분류: 수학, 이분 탐색
- 사용 언어: C++

## 문제 해설

해당 문제는 수식을 세우고, 그에 맞는 N과 M을 찾는 형식의 문제이다.

주어진 조건을 생각하면, “A, B가 주어질 때 a<x+1<b인 x+1의 개수를 구하여라”는 문제로 변환할 수 있다.

이때 조건은 다음과 같다.

1. x은 삼각형 모양으로 나열할 수 있다
2. x+1은 m x m 트레이에 넣을 수 있어야 한다. 즉, 모든 공을 넣었을 때 빈칸이 있으면 안된다.

이때 삼각형 모양으로 나열할 수 있는 수 x는 다음과 같은 꼴이다

x = 1 + 2 + ... + (n-1) + n = n(n-1)/2 (단, n은 자연수)

$x = n(n+1)/2$일 때,

$n(n-1)/2 + 1 = (n*n - n + 2)/2 = m * m$ 꼴이어야 한다.

좀 더 정리하면,

$n*n - n + 2 = 2 * m * m$과 같이 둘 수 있으나, 이때 a < b <= 10^9으로 a, b는 int의 최댓값보다 작은 1,000,000,000보다 작거나 같다.

문제는 2m \* m이 되면 값의 범위가 int의 최댓값을 넘는다(20억 정도).

즉, n(n-1)/2 + 1 = m \* m으로 구하도록 한다.

이를 통해 구할 과정은 이렇다.

1. 우선 a < n(n-1)/2 + 1 < b인 모든 n을 구하고,
2. 이 값이 n(n-1)/2 + 1 = m \* m으로 되는지 보기

나는 n을 구한 다음 그에 대해 m을 구하는 식으로 접근했다.

이때 구간을 만족하는 n을 찾기 위해서,

*a = n(n+1)/2 + 1*에 대해, (a - 1) \* 2 = n(n-1)이다.

다만 이를 정확하게 구하는 건 사실 비효율적이므로, *n = sqrt(a - 1) + 1*인 n부터 시작해서(정확하게 구하진 않았다) 조사하되, n(n-1)/2 + 1 > a일 때만 조사하도록 설계했다.

이때 다음 조건을 검사하는 게 어려웠는데,

$$
n(n-1)/2 + 1 = m * m
$$

m을 구하는 게 쉽지 않았다. 이를 해결하기 위해 실수를 사용하면, 부동소수점 문제가 발생할 위험이 컸다.

다만 double로 계산하는 게 편하므로, m은 sqrt로 구하고, long long으로 변환한 후 double로 변환한 (double)(long long) m이 기존 m과 동일한지 비교하는 것으로 해결했다.

위험성은 있지만 일단, 정답 범위 내에서는 문제가 없었다.

```cpp
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    for (int i = 1;;i++)
    {
        int a, b;
        cin >> a >> b;

        if (a == 0 && b == 0)
            break;

        int start = sqrt(a - 1) + 1;
        int answer = 0;
        for (long long n = start; (n * (n - 1) / 2 + 1) < b; n++)
        {
            // n(n+1)/2 + 1 = m * m?
            long long lhs = n * (n - 1LL) / 2LL + 1LL;
            if (lhs <= a)
                continue;

            double m = sqrt((double)lhs);
            if (m == (double)((int)m))
            {
                answer++;
            }
        }
        cout << "Case " << i << ": " << answer << '\n';
    }

    return 0;
}
```

사실 시간이 많이 걸린 이유는 n(n-1)/2 + 1이 아니라 n(n+1)/2 + 1을 사용했던 점과 cout에서 Case가 아니라 Cases를 출력해서 그렇다.

문제가 안 풀리면 출력 형식도 한 번 보도록 하자.

## 더 나은 풀이

다른 풀이를 보자면, 시간 면에서는 차이가 없지만 메모리 면에서만 차이가 있는 듯하다.

해당 문제는 이분탐색 문제인데, 반대로 M의 값을 결정해놓고 N의 값을 찾을 때 이분 탐색을 사용할 수 있다(그 반대도 가능하긴 할 거 같다).

a < m _ m < b에 해당하는 m의 값을 결정하고, m _ m = n(n-1)/2 + 1를 만족하는 n을 찾는 식이다.

이때 n을 찾기 위해서 값의 범위를 이분탐색으로 찾을 수 있다. 계산해보면 n의 범위는 4만을 안 넘으니, 1≤n≤4만의 범위에 대해서 n의 값을 탐색하면 된다. 그러면 최대 16회 내에 n의 값을 찾을 수 있으니 이 방법이 좀 더 오류 없이 정확한 방법이라 할 수 있다.
