# 10942번-팰린드롬?

## 문제

- 백준, 골드4, https://www.acmicpc.net/problem/10942
- 풀이 날짜: 2025.2.28.
- 풀이 시간: 11:34~12:06(32분)
- 알고리즘 분류: 다이나믹 프로그래밍
- 사용 언어: C++

## 문제 해설

해당 문제는 팰린드롬을 계산하는 문제이지만, 문제에서 쿼리할 때 조건이 걸려 있어 주의해야 하는 유형이다.

길이 L의 팰린드롬을 계산하는 데에 걸리는 시간은 O(L)이다.

따라서 M번의 질문을 한다면, 길이는 (E - S + 1)이므로 O(M(E - S + 1))의 시간이 걸릴 것이고, 평균적으로는 길이 L은 N/2이므로 시간 복잡도는 O(MN)에 비례하게 된다.

그런데 질문의 개수 M이 최대 100만이고 수열의 크기 N이 최대 2000이므로, MN ≤ 20억으로 0.5초 내로 해결하기에는 어려운 문제가 된다(대략 5천 만 번의 연산이 한계라 가정했을 때. 이는 1초에 1억 번의 연산을 수행한다는 가정에서 나온다).

이때 시간 복잡도가 증가하는 이유는 중복된 질문이 발생해서 그렇다. 질문이 완전 중복되지 않더라도, 팰린드롬에서 발생하는 연산에서 중복이 발생하게 되어 비효율성이 증가하게 된다.

팰린드롬은 뒤집었을 때에도 원문과 동일한 문자열을 의미한다(여기서는 문자열 대신 수열을 사용). 실제로 뒤집어서 똑같은지 계산할 수도 있지만, 중심점을 정해놓고 그곳에서부터 왼쪽 부분과 오른쪽 부분이 같은지 계산할 수도 있다.

이때, 중심점으로부터 점점 범위를 넓혀가며 팰린드롬인지 체크한다면, 좀 더 효율적으로 계산할 수 있다.

예를 들어, 1, 2, 1, 3, 1, 2, 1이라는 수가 주어지면

중심이 되는 수 3에 대해, 점점 범위를 넓히면서 계산한다고 해보자.

- 3: 팰린드롬
- 1 3 1: 팰린드롬
- 2 1 3 1 2: 팰린드롬
- 1 2 1 3 1 2 1: 팰린드롬

위 네 개 수열은 분명히 다른 수열이지만, 다른 수열의 계산 결과를 이용하여 계산을 최적화할 수 있다.

1, 3, 1은 중심이 되는 수 3을 기준으로, 양쪽에 있는 좌측 1, 우측 1을 비교하여 팰린드롬인지 확인할 수 있다.

2, 1, 3, 1, 2는 원래는 양 끝의 2와 중간에 있는 두 개의 1을 비교하여 팰린드롬인지 계산해야 한다. 즉, 비교 연산이 두 번 필요하다.

그렇지만 1, 3, 1이 팰린드롬이라는 것을 안다면 1, 3, 1의 양쪽에 2를 덧붙인 형태인 2, 1, 3, 1, 2는 양 끝에 붙어 있는 수 2만 비교하면 팰린드롬인지 확인할 수 있다. 즉, 비교 연산 단 한 번으로 계산할 수 있다.

이와 비슷한 원리로, 1, 2, 1, 3, 1, 2, 1은 2, 1, 3, 1, 2가 팰린드롬이므로, 양쪽에 1을 붙인 형태인 해당 수열도 팰린드롬이 된다.

이전에 계산한 결과를 이용하면서 계산의 순서를 잘 조정하면 계산을 효율적으로 수행할 수 있다. 이를 해낼 수 있는 것이 바로 다이나믹 프로그래밍이다.

내가 풀이할 땐 기본적으로 중심이 되는 수를 정하고, 그곳으로부터 범위를 넓혀가며 좌측과 우측이 대칭인지 비교하도록 했다.

이때 두 가지 케이스를 고려하여야 한다.

1. 수열의 길이가 홀수일 때
2. 수열의 길이가 짝수일 때

문제 예시에서는 수열의 길이가 홀수인 경우만 주어졌다. 그래서 기준이 되는 수는 단 하나밖에 없다.

그런데 수열의 길이가 짝수인 경우도 존재한다. 이때에는 기준이 되는 수가 두 개가 되므로, 별도 케이스로 고려해줘야 한다.

### 코드

두 가지 케이스를 계산하기 위해, 팰린드롬 계산을 위한 반복문을 두 개로 나누었다. 첫 번째는 수열의 길이가 홀수일 때, 두번째는 수열의 길이가 짝수일 때이다.

팰린드롬인지 아닌지 결과를 dp에 저장하도록 하였으며, dp[S][E]는 인덱스 S부터 인덱스 E까지의 수열이 팰린드롬일 경우 true, 아닐 경우 false를 갖도록 설계하였다.

다이나믹 프로그래밍으로 결과를 미리 계산해놓으면, 이를 이용하여 질문마다 dp[s][e]를 통해 팰린드롬인지 아닌지 확인할 수 있다.

```cpp
#include <iostream>
#include <cstring>

using namespace std;

bool dp[2001][2001];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, m, s, e;
    int data[2001];
    memset(dp, 0, sizeof(dp));

    cin >> n;

    for (int i = 1; i <= n; i++)
    {
        cin >> data[i];
    }

    // calculate dp(the case: (e - s + 1) is odd)
    for (int center = 1; center <= n; center++)
    {
        dp[center][center] = true;
        for (int i = 1; center - i >= 1 && center + i <= n; i++)
        {
            if (data[center - i] != data[center + i])
                break;
            dp[center - i][center + i] = true;
        }
    }

    // calculate dp(the case: (e - s + 1) is even)
    for (int center = 1; center <= n; center++)
    {
        for (int i = 0; center - i >= 1 && center + i + 1 <= n; i++)
        {
            if (data[center - i] != data[center + 1 + i])
                break;
            dp[center - i][center + 1 + i] = true;
        }
    }

    cin >> m;
    for (int i = 0; i < m; i++)
    {
        cin >> s >> e;
        cout << (dp[s][e] ? "1\n" : "0\n");
    }

    return 0;
}
```

### 더 나은 풀이

다른 분들의 풀이를 살펴보니, 아예 이중 반복문을 이용하여

```cpp
for (int i = n - 1; i >= 1; i--)
{
    for (int j = i + 2; j <= n; j++)
    {
        ...
    }
}
```

위와 같이 순회하면서, `data[i]==data[j]`이고 `dp[i+1][j-1]==true`면 팰린드롬으로 볼 수도 있다고 한다.

중요한 점은, 초기에 팰린드롬인 수를 지정해놓고(수가 하나인 경우, 수가 두 개인 경우) 다음으로 순회할 때 첫 시작 값은 역순으로 돌도록 한다는 점인 것 같다.
