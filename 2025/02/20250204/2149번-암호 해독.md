# 2149번-암호 해독

## 문제

- 백준, 실버 3, https://www.acmicpc.net/problem/2149
- 풀이 날짜: 2025.2.4.
- 풀이 시간: 12:30~13:06(36분)
- 알고리즘 분류: 구현, 문자열, 정렬
- 사용 언어: C++

## 문제 해설

해당 문제는 정렬 문제에 약간의 구현이 들어갔다.

1. 암호문은 행과 열이 뒤집힌 상태로 입력된다.
2. Key를 정렬했을 때(단, 안정 정렬이어야 한다) 정렬된 Key는 암호문의 각 열에 대응된다.
   1. 암호문의 각 열은 다른 열로 되돌려야 하는데, 이때 되돌려야 되는 열의 위치는 해당하는 정렬 Key의 기존 열이 된다.
   2. 뭔가 설명이 복잡한데, 각 문자에 인덱스가 0, 1, 2, 3, 4, 5로 부여되었을 때, Key를 정렬하고 나면 키를 순서대로 정렬했을 때 인덱스도 **3**, **4**, **1**, 0, 2, 5와 같이 섞여버린다. 이게 의미하는 바는, 첫 번째 열은 **3**번 열로, 두 번째 열은 **4**번 열, 세 번째 열은 1번 열로 이동하라는 뜻이 된다.
3. 암호문의 열을 키에 따라 원래 위치로 되돌리면 평서문이 완성된다.

이때 2차원 배열로 바꾸고 싶지 않아, 1차원 인덱스로 처리했다.

### 풀이

우선, N=(키의 길이), H=(암호문의 길이 / 키의 길이)라고 하자.

2차원 배열로 다룬다면, 암호문은 (N \* H)짜리 2차원 배열로 다룰 수 있지만, 여기서는 1차원 배열로 다뤄보자.

입력 암호문은 원래 암호문에서 열, 행이 바뀐 것이다.

여기서 열과 행을 바꾸게 되면, 원래는 [i][j] 위치에 있었던 것이 [j][i]로 바뀌게 된다. 1차원 인덱스로 나타내면 2차원 인덱스는 [i * h + j]이지만, i, j가 바뀌어 [j * h +i]가 된다.

즉, 원래 암호문[i][j]은 입력 암호문[j * h + i]이다.

이제 원래 암호문을 평서문으로 바꿔보자.

key를 정렬했을 때, 각 인덱스를 ik라고 해보자.

key[idx]에는 그에 대응되는 문제와 인덱스 ik가 있는데, idx번째 열에 있는 문자는 ik번째 열로 이동해야 한다.

그러면 원래 암호문[i][j]에 있던 문자는 평서문[i][ik]로 이동해야 한다. 여기서 열은 j로 표현할 것이니까, key[j]에 저장된 인덱스가 ik가 된다.

즉, 원래 암호문[i][j]의 문자는 평서문[i]key[j]의 원래 인덱스]이다.

이때 2차원 배열을 1차원으로 펼칠 거니까, 평서문의 인덱스를 (i \* n +key[j]의 원래 인덱스)로 표현 가능하다.

즉, 원래 암호문[i][j] → 평서문[i \* h +key[j]의 원래 인덱스]이고, 입력 암호문을 대입하면

`평서문[(i * n +key[j]의 원래 인덱스)] ← 입력 암호문[j * h + i]`이다.

이를 코드로 간결하게 표현해서 그렇지, 약간 변환 과정이 생략되어 있다고 보면 되겠다.

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

#define CIPair std::pair<char, int>
// CIPair: <char, index>

bool compare(CIPair a, CIPair b)
{
    if (a.first == b.first)
    {
        return a.second < b.second;
    }
    return a.first < b.first;
}

int main()
{
    char key[11];
    char cipher[101];
    char plain[101];
    int n, h;

    scanf("%s", &key);
    scanf(" %s", &cipher);

    n = strlen(key);
    h = strlen(cipher) / n;

    CIPair keyIndex[10];
    for (int i = 0; i < n; i++)
    {
        keyIndex[i] = std::make_pair(key[i], i);
    }
    std::sort(keyIndex, keyIndex + n);

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < n; j++)
        {
            int newJ = keyIndex[j].second;
            plain[i*n+newJ] = cipher[j*h+i];
        }
    }
    plain[n*h] = '\0';
    printf("%s\n", plain);

    return 0;
}
```

다만 이렇게 풀다 보니 너무 생각하는 과정이 복잡하고 실수가 잦아졌다.

다음부터는 메모리를 좀 더 쓰고 코드가 길어지더라도, 단순하고 명료하게, 중간 과정을 생략하지 말고 쓰도록 하자. 그래야 좀 더 실수가 줄어들 것이다.
