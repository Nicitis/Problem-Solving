# 5623번-수열의 합

## 문제

- 백준, 실버 4, https://www.acmicpc.net/problem/5623
- 풀이 날짜: 2025.3.29.
- 풀이 시간: 2:30~2:58(28분)
- 알고리즘 분류: 수학
- 사용 언어: C++

## 문제 해설

우선, 문제를 보았을 때 규칙성을 찾으려 해보았다. 문제의 특성상 수학적인 풀이가 필요하다 보았다.

(1) n=2일 때

n이 2일땐 무조건 나올 수 있는 경우는 다음밖에 없었다.

```cpp
0 2
2 0
정답: 1 1
```

왜냐하면 숫자가 두 개 있으면 a1+a2의 값만 알 수 있는데 이것만으로는 정답을 알 수 없다. $a_i$가 양의 정수라는 조건을 이용해야 해결할 수 있는데, 이러려면 s12 = s21 = 2여야 하고, 그 경우에만 a1=a2=1으로 두어 겨우 문제를 해결할 수 있다.

(2) n > 2일 때

입력으로 주어진 경우를 보자.

```cpp
0 3 6 7
3 0 5 6
6 5 0 9
7 6 9 0
```

대칭인 부분을 빼면 이를 이렇게 정리할 수 있다.

```cpp
a1+a2 = 3
a1+a3 = 6
a1+a4 = 7

a2+a3 = 5
a2+a4 = 6

a3+a4 = 9
```

이때 a1의 값은 다음과 같이 계산하여 구할 수 있었다.

```cpp
(a1+a2)-(a2+a3)=(a1-a3)=3-5=-2
(a1-a3)+(a1+a3)=(2a1)=-2+6=4
a1=2
```

이 점을 생각하면 다음과 같이 일반화할 수 있다.

`*a1 = (s12-s23+s13)/2*`

조금 더 나아가면, 이렇게 일반화 가능하다.

$$
a_i = (s(i,i+1)-s(i+1,i+2)+s(i,i+2))/2 \ \text{(단, } i \le n - 2\text{)}
$$

그런데 생각해보면, 인덱스는 크게 상관이 없다.

a2를 구하고 싶을 때, 다음과 같이 처음 인덱스로 다시 돌아가 계산하는 식으로도 처리 가능하다.

`*(a2+a3)-(a3+a1)+(a2+a1)=2a2=s23-s31+s21*`

즉, n≥3일 땐 이렇게 일반화할 수 있다.

$$
a_i = (s(i,(i+1)\mod{n})-s((i+1)\mod n,(i+2)\mod n)+s(i,(i+2)\mod n))/2 \ \\\text{(단, n > 2)}
$$

그런데 한편으로는 첫 항 a1만 이렇게 구하고, 다음부터는 s(1, i)를 이용해서 $a_i$를 구할 수도 있다.

$$
a_1 = (s(1,2)-s(2,3)+s(1,3))/2\\
a_i = s_{1,i}-a_1 (i > 1)
$$

이제 이를 구현해보자.

### 구현 1

i=0부터 시작하도록 하면, 수열은 a0에서 a(n-1)까지 이어진다. 따라서 변수명도 a0로 정했다.

```cpp
#include <iostream>

using namespace std;

int s[1000][1000];
int main()
{
    int n, a0;

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> s[i][j];

    // n == 2일땐 오직 a1 = a2 = 1밖에 없다.
    if (n == 2)
        cout << "1 1\n";
    else
    {
        a0 = (s[0][1] - s[1][2] + s[0][2]) / 2;
        cout << a0;
        for (int i = 1; i < n; i++)
            cout << " " << s[0][i] - a0;
        cout << "\n";
    }


    return 0;
}
```

그런데 이렇게 푸니 시간이 너무 많이 걸렸다(80ms).

따라서 해결 방법이 필요했는데, 다른 사람의 풀이를 보니 “입력을 모두 받을 필요가 없다”는 점을 알 수 있었다.

백준의 특성상, 스트림으로 입력받고 바로 출력한다. 따라서 모든 입력을 다 처리하지 않아도 되었던 것이다. 다소 꼼수 같긴 하지만, 1번째 줄, 2번째 줄 정도만 입력받아도 모든 결과를 처리할 수 있었다.

그래서 이를 수정하면 이렇게 된다.

```cpp
#include <iostream>

using namespace std;

int s[2][1000];
int main()
{
    int n, a0;

    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;

    for (int i = 0; i < 2; i++)
        for (int j = 0; j < n; j++)
            cin >> s[i][j];

    // n == 2일땐 오직 a1 = a2 = 1밖에 없다.
    if (n == 2)
        cout << "1 1\n";
    else
    {
        a0 = (s[0][1] - s[1][2] + s[0][2]) / 2;
        cout << a0;
        for (int i = 1; i < n; i++)
            cout << " " << s[0][i] - a0;
        cout << "\n";
    }


    return 0;
}
```
