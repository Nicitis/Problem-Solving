# 32343번-드랍 더 비트

## 문제

- 백준, 브론즈 1, https://www.acmicpc.net/problem/32343
- 풀이 날짜: 2025.3.12
- 풀이 시간: 22:32~22:46(14분)
- 알고리즘 분류: 그리디 알고리즘, 브루트포스, 비트마스킹, 수학
- 사용 언어: C++

## 문제 해설

다들 그리디 알고리즘으로 풀었는데, 나는 그냥 수학으로 푸니까 풀리더라.

x는 a개 자리가 1이고, y는 b개 자리가 1이다. 이때 x^y (이때 ^는 비트 단위 xor 연산)의 최댓값은, 결국 111110000 꼴의 1로 시작하고 0으로 끝나는 n자리 비트열이 된다.

만약 a+b가 n 이하라면, (a+b)개의 비트가 1인 비트열, 즉 가장 상위 비트부터 (a+b)개 비트가 1인 비트열이 될 것이다.

그런데 a+b이 n개 이상이라면, 겹치는 부분은 0이 될 것이다. 겹치는 개수는 (a+b-n)개이므로, 결국 1인 비트의 개수는 n - (a + b - n) = (2n - a - b)개가 된다.

이렇게 해수, 1인 비트의 개수를 k개라고 구했다고 하자.

이때, 최댓값은 다음과 같다.

$$
\begin{align*}
&2^{n-1} + 2^{n-2} + ... + 2^{n-k}\\
&= 2^{n-k}(1+2+4+...+2^{(n-1) - (n-k)})\\
&= 2^{n-k}(1+2+4+...+2^{k-1})\\
&= 2^{n-k} * (2^k-1)
\end{align*}
$$

이때, 2^k꼴의 지수승은 1 << k로 구할 수 있다.

```csharp
#include <iostream>

using namespace std;

int main()
{
    // x의 개수 : a개
    // y의 개수 : b개
    // x^y의 최댓값?
    // 1이 최대 min((a+b), N) = k개!
    // k개의 1을 가질 때, 최댓값은 얼마인가?
    // k개의 1 -> 2^(n-1) + 2^(n-2) + ... + 2^(n-k)
    //즉, 2^(n-k)(1+2+4+...+2^{(n-1) - (n-k) = k-1})
    // = 2^(n-k) * (2^k-1)

    // 1 + 2 + 4 = 8 - 1 = 2^3-1

    int n, a, b, k, answer;
    cin >> n >> a >> b;

    k = (a + b < n) ? (a + b) : (2 * n - a - b);
    answer = (1 << (n-k)) * ((1 << k) - 1);

    cout << answer;

    return 0;
}
```
