# 12015번-가장 긴 증가하는 부분 수열 2

## 문제

- 백준, 골드 2, https://www.acmicpc.net/problem/12015
- 풀이 날짜: 25.3.14.
- 풀이 시간: 10:35~12:44(2시간 9분, 풀이 확인: https://velog.io/@junttang/BOJ-12015-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-2-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-C)
- 알고리즘 분류: 이진 탐색
- 사용 언어: C++

## 문제 해설

‘가장 긴 증가하는 부분 수열’ 문제는 LIS(Longest Increasing Sequence) 문제라 부른다.

이 문제는 가장 긴 증가하는 부분 수열(https://www.acmicpc.net/problem/11053)의 어려운 버전인데, 이전에는 $n^2$의 시간 내에 문제를 해결해야 했지만 해당 문제는 $nlogn$의 시간 복잡도 내에 해결해야 한다.

### DP로 접근하기?

기본적으로 DP를 통해 접근하면 $O(N^2)$의 시간 복잡도를 가진다. DP에서는 각 숫자마다 자신의 이전에서 자신보다 작은 숫자로 끝나면서 가장 긴 부분 수열을 구해야 한다. 각 숫자마다 길이를 기록해 놓도록 하면, 각 숫자마다 최대 n번의 탐색으로 가장 긴 증가하는 부분 수열을 구할 수 있다. 이를 n번 반복하니, $O(N^2)$의 시간이 걸린다.

하지만 이는 시간복잡도 면에서 시간 초과가 발생할 가능성이 높다. 따라서 다른 방법을 찾아봐야 한다.

그래서 내가 다음으로 생각한 것은 PQ를 통해 시간 복잡도를 개선하는 방법이다.

가장 긴 증가 부분 수열을 구할 때 다음과 같은 과정을 거치도록 하려 했다.

- PQ에 <길이, 숫자>를 넣는다.
  - 정렬 순서는 길이 내림차순, 숫자 오름차 순으로
- Pop해서 가져온 값이 숫자가 나보다 크면 무시(따로 저장해놓기
- 나보다 작은 숫자 발견시 push

이렇게 하면 탐색 시간을 log n의 시간으로 줄일 수 있지 않을까 생각했다. 하지만 최악의 경우 숫자가 역순(50, 40, 30, 20, 10)으로 들어와서 숫자 하나마다 모든 PQ를 탐색하여 nlogn의 시간이 걸리고, 이게 n번 반복되어 $O(n^2logn)$의 시간이 소요될 수 있었다.

여기에서 문제가 생겨서, 지금의 방법으로는 해결이 불가할 것 같았다.

### 올바른 풀이: 이진 탐색

https://velog.io/@junttang/BOJ-12015-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-2-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-C

도무지 내가 풀 수 없는 문제인 것 같아서, 아예 풀이를 찾아보기로 했다.

결론부터 말하자면, 해결 방법은 이진탐색이었다.

가장 긴 증가하는 부분 수열은 단 하나만 존재한다. 처음 내가 생각했을 땐 여러 개의 부분 수열이 존재하니 이를 모두 저장해 놓아야 했다. 그러나 여기서 중요한 점은, 우리는 LIS의 구성 상태에 관심 있는 것이 아니라 그 길이에 관심에 있다는 점이다.

현재까지의 LIS 길이를 기억해놓고, 새로운 수가 나왔을 때 이를 업데이트해서 길이를 늘릴 수 있어야 한다. 하지만 한편, 그 앞의 내용은 어떻게 바뀌어도 상관 없다. 따라서, 현재 가장 긴 증가하는 부분 수열을 저장해 놓더라도, 다음 LIS를 찾을 땐 그 앞의 내용을 업데이트해도 된다는 것이다.

예를 들어서, 10 20 30 15 20 25 50 45 55 60이라는 수열을 가정해 보자(위 링크 참고).

- 수열을 처음부터 선형적으로 훑는다. 최초 원소를 LIS에 포함시킨다.
  - LIS: 10
- 이때 LIS 수열의 마지막 원소보다 큰 원소가 나오면 계속 삽입할 수 있다.
  - LIS: 10 20 30
- 이번 원소가 LIS 수열의 마지막 원소보다 작다면, 대체가 필요하다.
  이때, LIS 수열을 이루는 원소 중 탐색 원소보다 크거나 같은 첫 번째 원소를 찾는다.
  - LIS: 10 15 30 (15 삽입시)
  - 여기서는 20을 15로 대체했다. 증가하는 부분 수열은 최대한 작은 값을 쓰면 쓸수록 그 뒤에 더 긴 수열이 올 수 있어 유리하다.
  - 그런데 이렇게 대체하는 건 명백히 이상해 보인다. 15는 30보다 뒤에 있기 때문에 이어지면 안된다.
  - 그렇지만, 한편으로는 괜찮다. 현재 가장 긴 증가하는 부분 수열의 길이는 3이다. 이때 가장 긴 증가하는 부분 수열을 만들 땐 ‘마지막 원소가 뭔지’와 ‘현재 길이가 무엇인지’만 알아도 충분하다. 새로운 원소가 들어오면 30과 크기를 비교하고, 그보다 큰지, 작은지만 알아도 충분하다.
  - 여기서 LIS는 10, 15와 10, 20, 30 두 개가 있는 상황이지만, 가장 긴 LIS 10, 20, 30에서 앞에 10, 20이 온다는 사실은 사실 기억하지 않아도 괜찮다. 그렇기 때문에, 지금 구성 중인 LIS에서 바로 값을 20에서 15로 고쳐서 업데이트해도 괜찮다. 이렇게 하면 하나의 수열로 현재까지 LIS도 저장하고 미래의 LIS도 관리할 수 있다.
- 위 원리를 토대로 계속 훑는다.
  - LIS: 10 15 20 (20 삽입, 30을 20으로 대체한다. 여기까지는 기존 LIS가 가장 길다.)
  - LIS: 10 15 20 25 (새로운 LIS로 대체되었다!)
  - LIS: 10 15 20 25 50
  - LIS: 10 15 20 25 45
  - LIS: 10 15 20 25 45 55
  - LIS: 10 15 20 25 45 55 60 **(완성)**

이렇게 하면 하나의 수열만으로 모든 LIS를 관리할 수 있다.

여기까지 살펴보면, n개의 수를 삽입할 때, 마지막 원소보다 작은 값을 삽입하면 일정한 조건에 따라 값을 탐색한다. 그 조건은 다음과 같다.

- 자신과 가장 값이 비슷한데, 나보다 큰 값을 대체한다.
- 좀 더 다듬으면, LIS 수열을 이루는 원소 중 **탐색 원소보다 크거나 같은 첫 번째 원소**를 대체한다.

탐색 원소와 LIS 내의 원소가 값이 같으면 대체해도 결과가 같다.

하지만 LIS 내의 원소가 값이 더 크다면, 이는 대체하는 게 유리하다.

이때 값을 찾을 때 선형으로 순회하면 n^2의 시간이 걸린다.

그렇기 때문에 더 나은 방법을 찾아야 하는데, 이때 수열을 잘 보면 ‘오름차순’으로 정렬되게 되므로, 이진 탐색을 사용해서 이 값을 바로 찾을 수 있게 된다!

결국 직관으로 방법을 찾고, 그 속에서 규칙을 찾아야 한다. 이때 규칙에서 핵심 Idea를 도출해야 한다.

그런데 Idea를 구현할 때 어떻게 하면 좀 더 효율적으로 구현할지 고민하는 과정에서, 여기서는 이진 탐색을 활용하는 방안을 떠올릴 수 있다.

이러한 사고의 흐름에 익숙해지는 게 좋을 것 같다.

```csharp
#include <iostream>
#include <algorithm>

using namespace std;

int lis[1000000];

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, size = 0, last;
    cin >> n;

    cin >> lis[size++];

    for (int i = 1; i < n; i++)
    {
        cin >> last;
        if (lis[size - 1] < last)
        {
            lis[size++] = last;
        }
        else
        {
            int* it = lower_bound(lis, lis + size, last);
            *it = last;
        }
    }

    cout << size << '\n';

    return 0;
}
```
