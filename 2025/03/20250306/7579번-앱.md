# 7579번-앱

## 문제

- 백준, 골드 3, https://www.acmicpc.net/problem/7579
- 풀이 날짜: 2025.2.27., 2025.3.5., 2025.3.6.(해설 보기)
- 풀이 시간:
  - 2025.2.27: 11:05~12:32(포기),
  - 2025.3.5: 15:28~17:58(포기)
  - 4시간 시도 후 포기. 질문게시판 보기.
- 알고리즘 분류: 다이나믹 프로그래밍, 배낭 문제
- 사용 언어: C++

## 문제 해설

### 2월 27일 시도

O(N^3)이라 생각하고 1. 비용 순으로 오름차순 정렬, 2. 백트래킹으로 가능한 조합의 개수를 K개, K-1개, K-2개, …, 1개 순으로 모두 탐색하여 최소 비용 계산으로 처리하였다.

그런데 시간 초과가 떴다.

머리가 안 굴러가서 도무지 못 풀겠다.

### 3월 5일 시도

다시 생각해보면, 모든 경우의 수를 시도하면 2^N의 경우의 수가 존재하게 되어 있다.

따라서 최대한 경우의 수를 줄이기 위해 다이나믹 프로그래밍을 사용하는 방법을 떠올렸다.

DP를 이런 식으로 정의하도록 한다.

`DP[memory] = memory만큼의 메모리 용량을 확보할 때 필요한 최소 비용`

이때, A 앱을 지우고 나서 A 앱을 다시 지워서는 안된다. 따라서 앱을 첫 번째 앱부터 순차적으로 추가해가면서, 다음 식에 따라서 계산하도록 한다.

`DP[memory + app_mem] = min(DP[memory + app_mem], DP[memory] + app_cost)`

이때, 순회하는 순서를 잘못 설정하면 문제가 생길 수 있다. dp가 memory 크기만큼 길이가 필요하기 때문에, 만약 처음에 주어진 m보다 memory 용량이 커지면 m으로 제한하도록 했는데, 여기에서 문제가 발생했다.

500 Byte에서 500 Byte 짜리 앱을 지워서 1000 Byte를 확보해서 1000 Byte에서의 최소 비용을 갱신했다. 그런데 그 다음으로 1000 byte에서 똑같은 앱을 지워 500 byte를 확보하면, 같은 앱을 지웠을 때 나타나는 비용 dp[1000]을 활용하여 dp[1500]을 구하게 된다. 즉, 두 번 앱을 지우는 일이 발생할 수 있다.

그러나 이를 고려해도, 최악의 경우 앱 하나당 1000만 개의 DP를 탐색해야 할 수 있다. 즉, 최악의 경우 앱 100개를 지우기 위해 10억 번을 탐색해야 하므로 시간 초과가 발생할 수밖에 없다.

따라서 다른 접근 방식을 사용해야 한다.

### 다른 접근 방식

https://cocoon1787.tistory.com/319

다른 접근 방식은 위 글에 잘 정리되어 있다.

마찬가지로 앱마다 순회하는데 DP의 정의를 다르게 바꾸었다.

**DP[i][j]** : i번째 앱까지 확인했을 때 **j의 비용으로 얻을 수 있는 최대의 메모리**

여기서 생각해볼 점은 두 가지가 있다.

1. 앱의 정보를 i로 주도록 했다. 이는 중복으로 앱을 제거하지 않도록 방지해준다.
   1. i번째 앱의 비용을 계산할 땐 (i-1)번째 앱을 종료했을 때의 비용을 활용해서 계산해야 한다. 그런데 앱별로 배열을 구분하지 않으면, i번째 앱을 제거하고 나서 다시 i번째 앱을 추가 제거하는 일이 발생할 수 있다.
   2. e.g. 10의 비용에서 앱 A를 꺼서(10의 비용 사용) 20의 비용으로 메모리를 확보했다. 그런데 비용을 0부터 최대까지 순차 탐색하면, 여기에서 20의 비용에서 다시 앱 A를 꺼서 30의 비용으로 메모리를 다시 확보할 수도 있다.
   3. 탐색한 앱의 개수도 차원에 추가하면, 중복 제거를 막을 수 있다.
2. DP의 차원 정보를 메모리가 아니라 **비용**으로 주도록 했다. 총 사용 메모리는 최대 1000만이다. 반면, 총 사용 비용은 100개 앱 \* 최대 100의 단일 비용 = 최대 1만이다.
   1. 최대 메모리보다 최대 비용이 더 값이 작으므로, 여기에서는 최대 비용을 사용하는 것이 합리적이다.
   2. 이렇게 되면 앱마다 최대 1만 번만 검사하면 되므로 훨씬 효율적이라 할 수 있다.

이렇게 하고 나서, 앱을 종료할 때 mem만큼 메모리 확보되고 cost만큼 비용이 필요할 때

i번째 앱을 종료했을 때 [j + cost]에서 확보 가능한 메모리의 최대값은

`dp[i][j + cost] = max(dp[i-1][j + cost], dp[i-1][j] + mem)`

로 정의할 수 있다.

여기에서는 비용과 메모리 둘 중 어느 차원을 사용해도 괜찮으므로, 둘 중 더 경우의 수가 더 적은 쪽을 택하는 것이 유리하다.

이렇게, 다이나믹 프로그래밍을 할 땐 A를 차원으로 선택했을 때 너무 경우의 수가 많을 수 있다. 그 경우엔 다른 값 B를 차원으로 선택하여 해결했을 때 정답일 수도 있다.
