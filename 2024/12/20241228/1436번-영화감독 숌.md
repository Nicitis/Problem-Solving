# 1436번-영화감독 숌

## 문제

- 백준, 실버5, [1436번: 영화감독 숌](https://www.acmicpc.net/problem/1436)
- 풀이 날짜: 2024.12.28.
- 풀이 시간: 14:54~15:10(16분)
- 알고리즘 분류: 브루트포스 알고리즘
- 사용 언어: C++

## 문제 해설

규칙성을 찾을 수 없다면 가장 먼저 할 수 있는 방법은 브루트포스로 모두 찾는 것이다.

숫자를 1씩 높여가면서, 연속된 666이 나오면 count를 증가시키는 식으로 N번째 영화제목을 찾는 것이다.

이때, 연속된 666이 나왔음을 확인하기 위해 is666이라는 별도 함수를 활용한다.

컴퓨팅 파워에 의존하는 방법으로, N번째 영화제목의 숫자가 K라면 1부터 K까지의 숫자를 모두 조사하여야 하며 숫자 T를 조사할 때엔 T의 자릿수만큼 연산을 필요로 하게 된다.

즉, 3 + 3 + 3 + … + 4 + 4 + 4 + … + 5 + 5 + 5 + …와 같이 소요 시간은 숫자의 길이가 커질수록 더 증가하게 된다.

```cpp
#include <cstdio>

int is666(int n)
{
    while (n >= 666)
    {
        if (n % 1000 == 666)
            return 1;
        n /= 10;
    }
    return 0;
}

int main()
{
    int N;
    scanf("%d", &N);
    int num = 666 - 1;
    int series = 0;
    do
    {
        num++;
        if (is666(num))
        {
            series++;
        }
    } while (series < N);
    printf("%d\n", num);
    return 0;
}
```

다만 N이 1만으로 제한되어 있으므로 이 방법으로도 충분히 문제를 해결할 수 있다.

## 다른 풀이법

좀 더 효율적인 방법은 규칙성을 찾는 방법이다.

숫자 i 뒤에 666을 붙이는데, 만약 i의 마지막 자리가 6이라면, 66이라면, 666이라면 다른 규칙이 생기므로 주의해야 한다.

예를 들어 i가 6이라면,

5666까지 세고 나서 그 다음 숫자는 6666이 아니라 6660, 6661, 6662, …, 6668, 6669가 나와야 한다.

i가 16이라면 16666대신 16660, 16661, 16662, …, 16669까지 세야 한다.

i가 66이라면 또 반대로, 65666 다음에 66666이 아니라 66600, 66601, …, 66699까지 나온다.

i가 666이라면 665666 다음에 666666 대신 666000, 666001, …, 666999까지 증가한다.

이런 식으로 i의 마지막 자리가 666일 때, 그게 아니라 66일 때, 또 그게 아니라 6일 때 값이 다르게 나오므로 이를 잘 고려해서 값을 생성하는 식으로 진행할 수도 있다.
