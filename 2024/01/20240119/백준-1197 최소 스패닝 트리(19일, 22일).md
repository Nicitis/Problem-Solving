# 백준-1197 최소 스패닝 트리(19일, 22일)

## 문제

- 백준, 골드4, [1197번: 최소 스패닝 트리 (acmicpc.net)](https://www.acmicpc.net/problem/1197)
- 풀이 날짜: 2024.01.19., 2024.01.22
- 풀이 시간: 20:14~21:38 (실패), 20:20~
- 알고리즘 분류: 그래프, 최소신장트리

## 문제 해설

최소신장트리를 구현하는 문제이다.

여기서는 Kruskal 알고리즘을 사용하여 풀이했다.

Kruskal 알고리즘은 다음과 같은 순서로 이루어진다.

1. 간선을 가중치 기준으로 오름차순 정렬한다.
2. 가중치가 낮은 것부터, 간선을 추가했을 때 사이클이 생기면 그 간선은 무시한다.
3. 그렇지 않다면 간선을 최소신장트리에 추가한다.
4. 정점이 V개일 때 (V-1)개의 간선을 추가할 때까지 반복한다.

Kruskal 알고리즘은 O(ElogE)만큼 시간이 걸리지만, 구현에 따라 시간복잡도가 훨씬 증가할 수 있다.

19일, 그래프가 사이클을 형성하는지 검사하기 위해 처음에 선택한 방법은 실제로 DFS로 탐색하는 것이었다. 시간 초과가 나자, 재귀 방식을 사용해서 그런 줄 알고 스택으로 변경하였다. DFS를 계속 반복하는 것만으로 최소 O(V*V)의 시간이 소요된다. 따라서 실패한 이후에는 다른 방법을 시도하였다.

22일, 분리집합 방법을 사용하여 풀이하기로 했다. 나중에 알아보니 경로 압축 방법과 랭크(Union by rank) 방식이 있다고 하는데, 거기에서 경로 압축 방법만을 사용했다.

경로 압축 방법은 각 노드의 분리집합을 탐색할 때 그 경로에 있는 모든 노드의 부모를 가장 위의 부모로 바꿔주는 방법이고, 랭크는 큰 트리 아래에 작은 트리가 붙도록 하는 방법이다.

문제는, 두 분리집합을 합치는 UnionFind 함수(나의 경우 union_set)에서 구현을 잘못했다.

```cpp
// 두 분리집합을 합친다
void union_set(int a, int b, vector<int>& parent)
{
    int pa = find_set(a, parent);
    int pb = find_set(b, parent);
    parent[a] = pb;
}
```

위와 같이 구현할 경우, a의 부모만을 pb로 바꾸기 때문에 a가 속한 집합 자체는 b와 합쳐지지 않는다. 따라서 구현하려고 한다면 다음과 같이 `pa`의 부모를 바꿔야 적절하다.

```cpp
// 두 분리집합을 합친다
void union_set(int a, int b, vector<int>& parent)
{
    int pa = find_set(a, parent);
    int pb = find_set(b, parent);
    parent[pa] = pb;
}
```

또한, 문제 자체가 입력 개수가 많기 때문에 C++에서는 다음 코드를 추가해주는 것이 시간 면에서 좋다.

```cpp
ios_base::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
```