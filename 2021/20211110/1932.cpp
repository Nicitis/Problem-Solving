// 백준 1932: 정수 삼각형(C++)
// 정수 삼각형이 주어질 때 매 층마다 수 하나를 선택한다.
// 다만 다음 층에서는 이전 층의 대각선에 위치한 수만 선택할 수 있다.
// 수를 선택하는 데에 제약 조건이 있으므로 모든 경우를 시도해보아야 한다.
// 위층에 대해 중복 계산을 하지 않도록 하기 위해 dp를 사용한다.
// 층마다 해당 수를 선택할 때 만들 수 있는 최대 합을 배열로 저장하도록 한다.
// 예를 들어 3층에서 계산되는 dp 값은 1층에서 3층까지 범위에서 각 수를
// 선택할 때 만들 수 있는 최대 합을 저장한다.
// = 테스트 케이스 =
/*
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5

1
0

2
1
2 3
*/
// dp[y][x]의 좌측 대각선 위: dp[y-1][x-1]
// dp[y][x]의 우측 대각선 위: dp[y-1][x]
#include <cstdio>
#define MAX(X, Y) ((X)>(Y)?(X):(Y))

int main()
{
    int n;
    int dp[500][500] = { 0, };
    int max_sum = 0;

    scanf("%d", &n);

    for (int i = 0; i < n; i++)
    {
        // 해당 층에 대해 입력을 받는다.
        for (int k = 0; k <= i; k++)
        {
            scanf("%d", &dp[i][k]);

            if (i == 0)
                continue;

            if (k == 0)
            {
                dp[i][k] += dp[i-1][0]; // 좌측 원소는 우측 대각선 위
            }
            else if (k == i)
            {
                dp[i][k] += dp[i-1][k-1]; // 우측 원소는 좌측 대각선 위
            }
            else
            {
                // 좌측 대각선과 우측 대각선 위 중 더 큰 최대합을 선택
                dp[i][k] += MAX(dp[i-1][k-1], dp[i-1][k]);
            }
        }
    }

    // printf("== dp == \n");
    // for (int i = 0; i < n; i++)
    // {
    //     for (int k = 0; k <= i; k++)
    //         printf("%d ", dp[i][k]);
    //     printf("\n");
    // }
    // printf("== max == \n");

    // 마지막 층에서 최대합을 구함
    max_sum = -9999;
    for (int i = 0; i < n; i++)
    {
        max_sum = MAX(max_sum, dp[n-1][i]);
    }
    printf("%d\n", max_sum);
}