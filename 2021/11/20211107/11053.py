# 백준 11053: 가장 긴 증가하는 부분 수열(Python3)
"""
모든 수마다, 그 수를 마지막으로 하는 '가장 긴 증가 부분 수열'의 길이를 
기록한다.
i번째 입력까지 길이를 계산했다면, (i+1)번째 입력은 i번째까지의 
증가 부분 수열에 수 하나를 덧붙인 것과 같다. 즉, 자신 이전에 나온 입력에
의존하므로 dp를 통해 해결하였다.

새로운 수를 추가할 때마다 나보다 작은 수 중에서 가장 긴 부분 수열 길이를 
갖는 수와 연결한다.

예시 1)
10 20 10 30 20 50

예시 2) 가장 긴 부분 수열의 시작이 바뀐다
50 60 10 30 20 40

예시 3) 부분 수열의 중간 부분이 변경된다
10 20 50 30 40 60

겪었던 문제점: max_lengths[n]이 최대가 아니라 max(max_lengths)가 
최대라는 점
"""

# 입력
n = int(input())
seq = [0] + list(map(int, input().split())) # dummy [0]

# 증가하는 부분 수열 길이 구하기
# 각 수를 마지막으로 하는 '가장 긴 증가하는 부분 수열'의 길이
max_lengths = [0] + [1 for _ in range(n)] # dummy [0]
for i in range(1, n + 1):
  # 이전의 수를 통해 증가하는 부분 수열을 이룰 수 있는지 검사한다.
  for k in range(1, i):
    # 증가하는 수열을 이룰 수 있다면 최대 길이를 갱신한다
    if seq[k] < seq[i]:
      max_lengths[i] = max(max_lengths[i], max_lengths[k] + 1)

# 출력
print(max(max_lengths))