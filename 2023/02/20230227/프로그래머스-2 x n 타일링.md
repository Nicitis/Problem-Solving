# 프로그래머스-2 x n 타일링 #

## 문제 ##

- [코드](2xn_tiling.cpp)
- 프로그래머스, LV2, [코딩테스트 연습 - 2 x n 타일링 | 프로그래머스 스쿨 (programmers.co.kr)](https://school.programmers.co.kr/learn/courses/30/lessons/12900?language=cpp)
- 풀이 날짜: 2023.02.27
- 시간: 20:26~20:37(11분)
- 풀이 언어: C++
- 이미 예전에 풀어본 문제를 다시 풀어보았다.

타일을 배치하는 경우의 수는 가로로 배치하는 경우와 세로로 배치하는 경우가 있다.

가로로 배치하는 경우, 2x2의 공간을 차지한다.

세로로 배치하는 경우, 2x1의 공간을 차지한다.

2 x n 타일을 채우는 경우의 수는 2 x k (1 ≤ k ≤ n) 타일을 채우는 경우의 수로 표현할 수 있다.

1. 2 x (n-1) 타일의 가장 오른쪽에 세로로 배치된 타일 하나를 추가하는 경우와
2. 2 x (n-2) 타일의 가장 오른쪽에 가로로 배치된 타일 두 개를 추가하는 경우

2 x n 타일을 채우는 경우의 수를 f(n)이라 할 때,

n≥3에 대해 f(n)은 다음과 같다.

$$
f(n) = f(n-1) + f(n-2)
$$

f(1)은 2 x 1 타일을 채우는 경우의 수이므로 1개이고,

f(2)는 2 x 2 타일을 채우는 경우의 수이므로 가로로 배치하는 경우와 세로로 배치하는 경우 총 2개이다.

위 점화식을 통해 2 x n 타일링의 정답을 구할 수 있다.

그런데 위 점화식을 그대로 사용하면 f(n-1) = f(n-2) + f(n-3)으로 f(n-2)를 중복하여 구해야 한다는 문제점이 있다. 따라서 이를 해결하기 위해 DP(다이나믹 프로그래밍)를 사용해줄 수 있겠다.

```cpp
#include <string>
#include <vector>

#define MOD 1000000007

using namespace std;

int solution(int n)
{
    vector<int> dp(n + 1, 0);
    
    dp[1] = 1; // n = 1일 때
    dp[2] = 2; // n = 2일 때
    
    for (int i = 3; i <= n; i++)
    {
        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD; 
        // dp[k] (k>=1)는 최대 약 10억이므로, dp[i-1] + dp[i-2]도 int의 범위를 넘지 않는다.
    }
    
    return dp[n];
}
```
