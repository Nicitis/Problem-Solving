# 숫자 카드 나누기

- [코딩테스트 연습 - 숫자 카드 나누기 | 프로그래머스 스쿨 (programmers.co.kr)](https://school.programmers.co.kr/learn/courses/30/lessons/135807)

### 2월 21일 시도

풀이 시각: 19:53~20:24(실패)

- 어떤 수를 나누기 위해서는 그 수보다 작은 수로 나누어야 한다.
- 따라서 나눔수 a의 범위는 0<a≤max(min(arrayA), min(arrayB))인 정수 a여야 한다.
- 그러나 모든 수 a로 나누어보기에는 너무나도 많은 시간을 요구한다…
- 그래서 알고리즘의 개선이 필요한데 아이디어가 떠오르지 않는다.

### 2월 23일 시도

풀이 시각: 20:24~20:57

- 문제를 풀다가 포기하고 질문을 보았다.
- [[Kotlin 코드 O] 최대공약수를 이용한 방법입니다. | 프로그래머스 스쿨 (programmers.co.kr)](https://school.programmers.co.kr/questions/44005)

> **[Kotlin 코드 O] 최대공약수를 이용한 방법입니다.**
> 
> 
> 최대공약수를 이용해 각 배열의 최대공약수를 구하고
> 최대공약수가 있다면 그 값으로 반대쪽 모든 값들을 나누어 나머지가 없는 경우 왼쪽의 max값
> 반대로 오른쪽의 max값을 구해 둘 중에 큰 값을 확인하는 방식으로 하였습니다.
> 그리고 gcd 함수를 tailrec 으로 하면 좀 더 시간 단축이 가능한데 나중에 떠올랐네요.
> 궁금하신게 있으시다면 답글 부탁드립니다.
> 

해당 문제를 요약하면 다음과 같다.

- 배열 A와 배열 B 중 어느 하나의 모든 원소를 나눌 수 있으면서 나머지 배열의 어떤 원소도 나눌 수 없는 가장 큰 양의 정수 a를 구하라.

이때, 어떤 배열의 모든 원소를 나눌 수 있는 가장 큰 양의 정수는 ‘최대공약수’이다.

즉 이 문제를 다시 해석하면,

- (1) 배열 A의 최대공약수이면서 배열 B의 원소를 하나도 나누지 못하는 원소나
- (2) 배열 B의 최대공약수이면서 배열 A의 원소를 하나도 나누지 못하는 원소 중
- 가장 큰 원소를 구하여라.

여기서, 배열 A의 최대공약수이면서 배열 B의 원소를 하나라도 나눈다면, 배열 A의 최대공약수보다 작은 수 중 조건을 만족하는 수는 없을까?

### 최대공약수보다 작은 수 중 조건을 만족하는 수가 없다는 증명

1. gcd(A)가 배열 B의 원소를 하나라도 나눈다면, gcd(A)의 약수 또한 그 원소를 나눈다.
2. 배열 A의 모든 원소를 나눈다는 것은 배열 A의 공약수임을 뜻한다.

원소 n, m의 소인수 분해가 다음과 같이 주어질 때,

$$
n = p_1^{e_1} p_2^{e_2} ...p_t^{e_t} \\
m = p_1^{f_1} p_2^{f_2} ...p_t^{f_t}
$$

원소 n, m의 공약수(common factor)와 최대공약수 gcd는 다음과 같다.

$$
common\ factor \{ n, m \} = p_1^{a_1} p_2^{a_2} ...p_t^{a_t} (a_i는\ 0\le a_i \le min \{ e_i, f_i \} 인\ 정수)\\
gcd \{ n, m \} = p_1^{min \{ e_1, f_1 \}} p_2^{min \{ e_2, f_2 \}} ...p_t^{min \{ e_t, f_t \}}
$$

(단, p_i는 p_i<p_{i+1}인 소수)

이 정의에 의하면, 원소 n, m의 공약수는 최대공약수를 나눌 수 있고, 최대공약수가 나눌 수 있는 수는 공약수 또한 나눌 수 있음을 의미한다.

즉, 배열 A의 최대공약수가 배열 B의 아무 원소를 나눌 수 있다면 배열 A의 모든 공약수 또한 배열 B의 아무 원소를 나눌 수 있으므로 ‘배열 A의 모든 수를 나누면서 배열 B의 어떤 원소도 나누지 못한다’는 조건을 만족하는 수가 존재하지 않는다.

이는 배열 B의 최대공약수에 대해서도 동일하게 증명할 수 있다.

즉, **‘어떤 배열의 최대공약수이면서 다른 배열의 어떤 원소도 나누지 못하는 원소’**만이 정답의 조건을 만족하는 수이다.
