# 백준-12865 평범한 배낭

## 문제

- 백준, 골드5, [12865번: 평범한 배낭 (acmicpc.net)](https://www.acmicpc.net/problem/12865)
- 풀이 날짜: 2023.11.1
- 풀이 시간: 10:38~11:20, 12:47~13:06, 14:37~15:35(1시간 59분 소요)
- 알고리즘 분류: 다이나믹 프로그래밍, 배낭 문제

## 문제 해설

### 첫 번째 시도: 브루트포스(백트래킹)로는 풀 수 없다

[코드(실패)](12865-1(fail).cpp)

브루트포스로는 해결할 수 없는 문제이다. 브루트포스는 2^200, 즉, 못해도 10^20만큼의 시간은 걸린다. 이는 시간 복잡도적으로 해결할 수 없다.

### 두 번째 시도: 모든 무게와 물건에 대해 dp 수행하기

[코드(실패)](12865-2(fail).cpp)

그래서 dp로 문제를 풀어보기로 했다.

1부터 k-1까지의 무게에 대해서, 모든 물건을 하나씩 추가해보는 것이다.

그렇게 해서 나온 값 중 가장 큰 value를 선택한다.

그러나 해당 알고리즘의 문제점은, 같은 물건을 여러 번 사용할 수도 있다는 점이다.

해당 문제에서는 제대로 명시되어 있지 않지만, 같은 물건을 여러 개 넣을 수는 없다. 그러니까 이 방법에서는 이중 for문을 사용하는데 각 무게에 대해 한 번, 모든 물건에 대해 한 번 순회를 수행한다.

```c
// 의사 코드
for 0 <= x < (k - 1) 범위에 있는 무게 x에 대해
	for 모든 물건 (w, v)에 대해
		dp[x + w] = max(dp[x] + v, dp[x + w])
		dp 값이 더 크면 max_val 갱신하기
```

의사 코드로 나타내면 위와 같다. 그런데 이 경우, (w, v)의 1번 물건을 넣었던 값이 dp[w]에 저장되었다 보니 x=w가 되면 dp[w+w] = dp[w] + v로 같은 물건을 두 번 넣을 수도 있었다!

### 세 번째 시도: 각 물건마다 모든 무게에 대해 dp 값 계산하기

[코드](12865.cpp)

그래서 순서를 바꾸어서, 각 물건을 한 번만 넣도록 순서를 바꾸기로 했다.

```c
// 의사 코드
for 모든 물건 (w, v)에 대해
	for 0 <= x <= (k - w) 범위에 있는 무게 x에 대해
		dp[x + w] = max(dp[x] + v, dp[x + w])
		dp 값이 더 크면 max_val 갱신하기
```

이렇게 순서를 바꾸니 각 물건을 한 번만 넣어 검사할 수 있게 되었다.

그런데 문제점은, x를 0부터 (k-w)까지 순차적으로 증가시킬 경우 물건 하나 (1, 1)을 선택했을 때 dp[1]에서 한 번, dp[1+1]에서 한 번, dp[1+1+1]에서 한 번, 이런 식으로 또 여러 번 넣는 경우가 발생했다.

이를 막기 위해 x를 역순으로(감소하는 식으로) 순회하도록 했다.

소스 코드를 찾아봤는데 다른 사람의 풀이도 비슷하게 되어 있었다.

[36197977번 소스 코드 (acmicpc.net)](https://www.acmicpc.net/source/36197977)

대신 좀 더 짧고 명료하다. 예쁘게 코드 짜는 연습을 해야 되겠다.

## 반례

```c
3 9
8 8
3 3
7 7
Output: 8
여기서 자꾸 결과가 9가 나와 문제가 생겼다.
```

## 알게 된 것

[C++ 람다 식 | Microsoft Learn](https://learn.microsoft.com/ko-kr/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170)