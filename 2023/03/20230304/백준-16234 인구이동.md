# 백준-16234 인구이동

## 문제

- [코드](16234.cpp)
- 백준, 골드 5, [16234번: 인구 이동 (acmicpc.net)](https://www.acmicpc.net/problem/16234)
- 풀이 날짜: 2023.03.04.
- 풀이 시간: 16:30~17:24, 17:37~17:41, 20:09~20:20 (약 1시간 9분 소요)
- 중간에 구현하다 막혀서 저녁 먹고 와서 다시 풀었다.

### 주어진 문제

해당 문제는 인구 이동 행위가 몇 번 일어나는지를 구해야 한다.

모든 국가는 1x1 정사각형 형태이고 N x N 크기의 땅이 주어지므로 N x N 2차원 배열로 저장할 수 있다.

모든 국가별로 이웃한 국가와 L명 이상 R명 이하만큼 인구 수가 차이가 날 때 국경이 열린다(인구 이동의 조건).

국경이 열린 국가끼리 같은 연합이 되고, 같은 연합끼리는 인구를 균등하게 분배한다(인구 이동).

그 후 연합을 해체하고 모든 국가는 국경을 닫는다.

이렇게 인구 이동이 한 번 일어나면 1일이 흐른다고 가정하고, 인구 이동이 며칠간 일어나는지를 구해야 한다. 즉, 인구 이동이 몇 번 일어나는지를 구해야 한다.

### 문제 해결 과정

인구 이동은 많아야 2000일까지 일어나고 땅의 크기도 50 x 50이므로 모든 땅을 각각 탐색해도 2500번밖에 안된다. 같은 연합을 찾고 인구를 분배하는 데에 2500 * K번의 연산이 필요하므로, 별 다른 최적화를 하지 않아도 2000번 수행하는 데엔 무리가 없다고 판단했다.

같은 연합끼리 묶는 것은 분리 집합(Disjoint set) 연산과 그래프의 연결 성분 연산(DFS)을 활용할 수 있다.

우선 그래프의 DFS 탐색을 통해 각 국가가 어떤 연합에 속하는지 연산한다(`vector<vector<int>> unions` 2차원 배열에 저장). 연합 번호를 -1로 지정해놓았다가, 방문할 때 연합 번호를 지정해준다.

이 과정에서 각 연합별 총 인구수(`vector<int> people`), 각 연합에 소속된 국가의 수(`vector<int> unionCount`)를 함께 구한다.

![연합 번호는 [(행 번호 * N) + 열 번호]로 지정함](백준-16234_인구이동/연합번호_구하기.png)

연합 번호는 [(행 번호 * N) + 열 번호]로 지정했다.

각 국가가 어떤 연합에 속하는지와 각 연합별 인구수를 계산했다면, 이제 이를 분배한다.

r행 c열에 있는 국가의 인구수는 nations[r][c] = (r행 c열의 국가가 속한 연합의 총 인구 수) / (r행 c열의 국가가 속한 연합의 총 국가 수)이다.

다른 국가에 국경을 열어서, 다른 국가와 연합 중인 국가가 있다면, 인구 이동이 일어났다고 간주한다.

위 과정을 인구 이동이 일어나지 않을 때까지 반복하면 문제를 해결할 수 있다.

### 문제점

실행 시간이 100ms나 걸린다.

원인은 다음으로 보인다.

1. GetUnionNumber() 함수에 곱셈(*) 연산이 들어가서 시간이 많이 걸릴 수 있다.
2. 인구 이동을 수행하는 TryShifting() 함수와 국경을 열고 각 국가마다 연합을 만드는 OpenBoundaries() 함수에서 vector&를 계속해서 복사하는 것이 비효율적일 수 있다.

### 해결 방법 및 다른 사람의 코드

1번 문제는 dfs 연산을 수행하는 OpenBoundaries() 함수가 인구 이동까지 동시에 진행하지 못하는 바람에 생긴 문제다. OpenBoundaries() 함수가 종료되고 나서 각 국가별로 어떤 연합에 속하는지 구분하려면, 넘버링 과정이 필요한 것이다. 그래서 GetUnionNumber() 함수를 사용해서 넘버링을 하는데, 내가 그 과정에서 비싼 곱셈 연산을 사용해버렸다.

해결 방법은

1. 곱셈 대신 쉬프팅 연산이나 다른 효율적인 넘버링 방법을 고안하거나
2. 넘버링하는 대신, dfs 연산을 수행하는 함수 내에서 인구 이동 연산까지 모두 진행해버리면 된다.

이를 보여주는 좋은 코드가 바로 이 문제 풀이 1위가 푼 코드([24339066번 소스 코드 (acmicpc.net)](https://www.acmicpc.net/source/24339066)다.

```cpp
typedef struct point{
	int x, y;
}point;
int N, L, R, A[52][52], top, val, cnt, st_s;
int dx[4]={-1, 0, 1, 0}, dy[4]={0, 1, 0, -1};
bool visit[52][52];
point S[2500], st[2500];
void dfs(int x, int y){
	if(visit[x][y])	return;
	visit[x][y]=1;
	S[top++]={x, y};
	val+=A[x][y];
	... // dfs 과정
	if(top>1 && x==S[0].x && y==S[0].y){
		val/=top;
		for(int i=0;i<top;++i){
			A[S[i].x][S[i].y]=val;
			st[st_s++]={S[i].x, S[i].y};
		}
		cnt=1;
	}
}
```

위 코드는 연합번호를 따로 저장하지 않는다. 대신 top과 스택 S(point S[2500])로 방문한 국가의 위치를 기록한다. 전역 변수 val로 같은 연합의 인구 수를 기록한다.

그리고 국경을 열 수 있는 모든 국가를 방문하고 나서는 `if(top>1 && x==S[0].x && y==S[0].y)`로 조건을 판별하고, 스택 내에 있는 모든 국가에 대해 인구를 변경한다.

대상 위치를 스택으로 기록해놓는 방법의 장점은 top만 0으로 초기화해주면 스택도 초기화된다는 것이다. 실행 시간도 빠르고 간편하게 구현할 수 있어 좋은 아이디어 같다.

```cpp
for(int i=0;i<tmp;++i){
	dfs(tmp_st[i].x, tmp_st[i].y);
	top=0, val=0;
}
```

위 코드에서 2번 문제 또한 해결되는데, 위 코드에선 지속적으로 사용해야 하는 변수를 전역 변수로 선언한다.

함수의 파라미터로 계속 전달해야 한다면, 차라리 위처럼 전역 변수로 넘기는 방법도 나쁘지 않을 것 같다. Problem Solving에서나 사용가능하고 실무에서는 지속적으로 메모리를 점유한다는 문제가 있다. 그러나 적당한 타협만 한다면 코드도 깔끔하게 정리할 수 있으니… 파라미터 전달 때문에 머리가 터지기 싫다면 어느 정도는 필요할 수도 있겠다.

실무에서는 그 지옥의 파라미터 전달을 회피하기 위해 파라미터용 구조체를 별도로 선언한다. 다만 PS에서는 빠르게 푸는 게 중요하니 그렇게까지는 하기 힘들 듯하다. 전역 변수 쓰는 것도 고려하자.
