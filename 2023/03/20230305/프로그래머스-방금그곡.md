# 프로그래머스-방금그곡

## 문제

- [코드](that_song.cpp)
- 프로그래머스, Lv2, [코딩테스트 연습 - [3차] 방금그곡 | 프로그래머스 스쿨 (programmers.co.kr)](https://school.programmers.co.kr/learn/courses/30/lessons/17683)
- 풀이 날짜: 2023.03.05.
- 풀이 시간: 약 27분(lv2 스킬체크) + 1시간 14분 (16:23~17:37) = 약 1시간 41분
- 알고리즘 분류: 문자열

### 문제 해설

해당 문제는 네오가 기억하는 패턴 m(melody)과 노래에 대한 정보를 담은 문자열의 배열이 주어질 때 다음과 같은 조건이 일치하는 노래의 타이틀을 구해야 한다.

- 방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.
- 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.
- 각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.
- 음악이 00:00를 넘겨서까지 재생되는 일은 없다.
- 조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.
- 조건이 일치하는 음악이 없을 때에는 “`(None)`”을 반환한다.

분당 하나의 음만을 재생하여 12:02에 시작하여 12:04에 노래가 종료되었다면 총 3개의 음을 재생했다고 볼 수 있다. 따라서 m을 노래 내에서 찾을 수는 있지만 재생 시간이 짧아서 실제로는 재생되지 않았다면, 조건이 맞지 않는다고 본다.

예를 들어 음악 시작이 12:00, 종료가 12:05, 악보가 “ABC#ABC”이고 m이 “ABCABC#”이라면 ABCABC#의 멜로디가 존재하지만 음악 재생 시간 내에 나올 수가 없다(ABCABC#을 재생하려면 C#은 12:08이 되어서야 나올 수 있다). 따라서 조건이 일치하지 않는다고 본다.

1. **분리**: 문제를 풀기 위해서는 우선 주어진 문자열 배열 `vector<string> musicinfos`를 컴마(,) 단위로 분리해서 별도의 데이터로 저장해야 한다. istringstream과 getline을 이용하여 문자열을 컴마(,) 단위로 분리하도록 하였다.
    
    istringstream을 사용하지 않고 분리하려면 string.find() 함수와 string.substr() 함수로 컴마(,)마다 분리해줄 수 있겠다.
    
2. **정렬**: 해당 문제에서는 조건이 일치할 때 가장 재생 길이가 긴 음악 제목을 반환한다고 한다(만약 재생 길이가 동일한 음악들이 있다면 그 중 가장 앞의 것을 택함). 재생 길이 순으로 안정적인 정렬을 사용하면 재생 길이가 동일할 경우 원래 가장 앞에 있던 음악이 먼저 나오게 할 수 있다. 따라서 안정적인 정렬인 stable_sort를 통해 재생 길이가 긴 순서로 음악 정보를 정렬하고, 조건이 일치하는 음악이 있으면 바로 반환하도록 한다.
3. **패턴 비교**: 그 다음엔 패턴이 동일한 악보를 찾는다. 멜로디 m과 악보 song을 비교하는데 노래의 끝에 도달하면 다시 처음으로 가야 하므로 나머지 연산으로 음표를 획득하고 비교한다.
    
    이때, C#이나 C나 모두 같은 하나의 음표라는 것에 주의해야 한다. 모든 멜로디 m이 일치하더라도 악보에서 그 다음에 음표에 #이 나오면 패턴이 다르다고 판단한다.
    
4. **음악 길이 체크**: 조건을 만족하더라도 음악이 재생된 시간 내에 멜로디 m이 모두 나올 수 있는지 확인해야 한다. # 때문에 길이 계산이 어려워서 다음과 같은 수식을 사용했다.
    
    ```cpp
    int mLength = m.length() - std::count(m.begin(), m.end(), '#');
    int sharpCount = 0; // sharpCount는 #이 하나 나올 때마다 증가시킨다.
    
    for (int i = 0; i < song.length(); i++)
    {
    	// 곡의 길이를 초과해도 패턴이 다르다 판단한다.
    	int currentPlayTime = (i - sharpCount) + mLength - 1;
    	if (currentPlayTime > totalPlayTime)
    		continue;
    }
    ```
    

재생 길이는 (음악이 끝나는 시각) - (음악이 시작되는 시각)으로 구했다.

시각은 문자열에서 숫자로 변경해주어야 서로 뺄 수 있으므로 (시간 * 60 + 분)으로 계산한다.

### 문제점

> 부분 문자열 비교를 묻는 문제입니다. 하지만 멜로디의 각 음을 나타내는 글자가 한 글자일 수도 있고, 두 글자일 수도 있습니다. “ABC”라는 멜로디는 “ABCD”라는 악보에는 들어있지만, “ABC#”라는 악보에는 들어있지 않습니다. C#이 하나의 음을 이루고 있기 때문이죠.
> 
> 
> 문자열 비교에서 이런 문제를 처리해야 할 일이 있습니다. 1차 코딩 테스트에서 설명했던 토큰화Tokenizing를 통해 “ABC#”을 [“A”, “B”, “C#”] 식의 배열로 변환한 후에 비교를 수행할 수도 있고요. 아니면 두 글자로 된 “C#”, “D#”, “F#” 등을 악보에서 사용되지 않는 문자인 “c”, “d”, “e” 등으로 치환Substitution한 후에 문자열 비교 함수를 이용할 수도 있습니다.
> 
> 이 문제의 정답률은 47.50%였습니다. Python 사용자들이 가장 잘 풀었습니다.
> 

카카오 해설지([카카오 신입 공채 3차 코딩 테스트 문제 해설 – tech.kakao.com](https://tech.kakao.com/2017/11/14/kakao-blind-recruitment-round-3/#%EB%AC%B8%EC%A0%9C4-%EB%B0%A9%EA%B8%88%EA%B7%B8%EA%B3%A1))에 따르면, 해당 문제는 문자열의 변환, 가공이 핵심이다. 초기에 악보를 변환해주는 과정을 거쳐야 쉽게 풀 수 있다고 한다.

악보의 음표로 C, C#, D, D#, E, F, F#, G, G#, A, A#, B가 나올 수 있는데, 음표가 C도 나올 수 있고 C#도 나올 수 있어서 문자열의 길이가 음악의 길이와 다를 수 있다. 따라서 초기에 음표 단위(C, C#)로 별도로 악보를 저장하거나, c, d, f, g, a(소문자)를 사용하지 않는다는 사실에 착안해 #이 붙으면 대문자를 소문자로 변환해주는 방법이 있다.

이러한 작업을 거치지 않아서 음악 재생 길이를 비교하는 게 너무 어려웠던 것 같다.

### 자잘한 아쉬운 사항

- 악보는 song이 아니라 notes로 명명했으면 더 좋았을 것이다.