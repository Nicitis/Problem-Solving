# 프로그래머스-3xn 타일링 #

## 문제 ##

- [코드](3xn_tiling.cpp)
- 프로그래머스, Lv2, [코딩테스트 연습 - 3 x n 타일링 | 프로그래머스 스쿨 (programmers.co.kr)](https://school.programmers.co.kr/learn/courses/30/lessons/12902)
- 풀이 날짜: 2023.03.05.
- 풀이 시간: 약 33분(LV2 스킬 체크 1번) + 14:56~13:00
- 알고리즘 분류: 수학

### 문제 해설 ###

문제를 요약하면 다음과 같다.

> *2x1 블럭과 1x2 블럭이 주어질 때, 3 x n 타일을 모두 채울 방법의 수를 구하여라.*
> 

이 문제는 3 x n 타일을 채우기 위해 그보다 더 작은 문제의 답을 활용할 수 있다. 즉, 해당 문제의 답은 점화식을 통해 구할 수 있다.

[프로그래머스-2 x n 타일링](https://www.notion.so/2-x-n-0dcac5ebf1574b81bd6ac64d98de9903)과 동일해보이지만, 세로 길이가 1 더 늘면서 엇갈리게 배치하는 방법이 생겼다.

![엇갈리게_배치하기.png](프로그래머스-3xn%20타일링/엇갈리게_배치하기.png)

따라서 배치할 때 고려할 방법이 더 많아진다.

3 x n 타일을 채울 방법의 개수를 f(n)이라 하자.

n=1일 때부터 f(n)을 구해보자.

1. 초기값으로 f(0)=1이라 하자.
2. n=1일 때, 3 x 1 타일을 채워야 하는데 블럭의 크기는 2 x 1과 1 x 2밖에 없다. 즉, 채울 방법이 없으므로 f(1) = 0
3. n=2일 때 다음과 같이 3가지 방법이 있다.
    
    ![n이 2일 때.png](프로그래머스-3xn%20타일링/n이%202일%20때.png)
    
4. n=3일 때 3 x 3 타일을 채워야 한다. 총 9칸을 채워야 하지만, 채울 수 있는 블럭의 크기는 2이다. 이를 확장하면, n이 홀수(n=2k+1, k는 음이 아닌 정수)일 때는 3 x (2k+1) = 6k + 3 = 2(3k+1)+1칸을 2칸 블럭으로 채워야 한다. 그런데 이는 홀수이므로 2로 나눠지지 않는다. 즉, n이 홀수일 땐 f(n)=0이다.
5. n=4일 때엔 f(2)를 활용하여 구할 수 있다. 그런데, 엇갈려 배치하는 방법 2가지까지 포함하면, f(4)=f(2) * f(2) + 2 = 3 * 3 + 2 = 11이 된다.
    
    ![n이 4일 때.png](프로그래머스-3xn%20타일링/n이%204일%20때.png)
    
    위 그림에서 f(4) = 3 + 3 + 3 + 2 = 11
    
6. n=5일 때 n이 홀수이므로 0
7. n=6일 때부터는 기존 배치(f(2), f(4), …)의 가장 오른쪽에 엇갈려 배치한 블럭을 추가하는 식으로 계산했다.
    1. 가로 6칸으로 엇갈려 배치하는 경우 2가지
    2. (3 x 2 타일을 채우는 방법의 수) x 가로 4칸으로 엇갈려 배치하는 경우 2가지
    3. (3 x 4 타일을 채우는 방법의 수) x (3 x 2 타일을 채우는 방법의 수)
    
    여기서 마지막에서는 3 x 2 타일을 채울 때 엇갈려 배치하는 방법의 수가 없으므로 3 x 2 타일을 채우는 방법의 수를 곱해주었다.
    
    ![n이 6일 때.png](프로그래머스-3xn%20타일링/n이%206일%20때.png)

    $$
    f(6) = 2 + (f(2) \times 2) + f(4) \times f(2)
    $$
    
    처음 3 x 6 크기로 엇갈려 블럭을 배치하는 방법을 구하는 것은 f(0) * 2로 둘 수 있다. 그러면 다음과 같다.
    
    $$
    f(6) = \{f(0) \times 2\} + \{ f(2) \times 2 \} + \{f(4) \times f(2)\}
    $$
    
8. n=8을 구할 때에도 위와 같이 식을 세울 수 있겠다.
    
    $$
    f(8)=\{f(0) \times 2\} + \{ f(2) \times 2 \} + \{f(4) \times 2\} + \{f(6) \times f(2)\}
    $$
    

이를 일반화하면 다음과 같다.

$$

f(n)=
\begin{cases}
0, & \text{if n이 홀수일 때} \\
\displaystyle
2\sum_{i=0}^{n-4}f(i)+f(n-2) \times f(2), & \text{if n이 짝수일 때}
\end{cases}
$$

위 점화식은 그대로 dp 알고리즘으로 구현하면, f(i)를 구할 때 O(i)의 시간이 걸리므로 f(n)을 구하기 위해서는 O(n^2)의 시간이 소요된다.

위 점화식을 좀 더 정리해보자.

n이 짝수일 때, f(2)=3이므로  f(n-2)는 다음과 같다.

$$
\begin{align}
f(n-2)
&=\displaystyle
2\sum_{i=0}^{n-6}f(i)+f(n-4) \times f(2)\ \\
&= \displaystyle
2\sum_{i=0}^{n-4}f(i)+f(n-4)
\end{align} \\
\displaystyle
2\sum_{i=0}^{n-4}f(i) = f(n-2)-f(n-4)
$$

위 식을 이용해 f(n)을 다시 정리하면 다음과 같다.

$$
f(n)=
\begin{cases}
0, & \text{if n이 홀수일 때} \\
\displaystyle
4f(n-2) - f(n-4), & \text{if n이 짝수일 때}
\end{cases}
$$

이제 해당 점화식을 DP 알고리즘으로 구하면 된다.

### 문제점 ###

문제 자체는 간단했으나, 1,000,000,007로 나눈 나머지끼리 뺄셈을 하다 보니 음수가 나올 수 있다는 사실을 눈치채지 못했다.

```cpp
// 아래와 같이 짜면 음수가 나올 수 있다.
dp[i] = (4 * dp[i-2] - dp[i-4]) % 1000000007LL;
// 따라서 1000000007을 더한 후 계산해줘야 한다.
// 이를 위해서는 long long을 사용하는 편이 좋을 것 같다.
dp[i] = ((4 * dp[i-2] % 1000000007LL) - dp[i-4] + 1000000007LL) % 1000000007LL;
```

따라서 위와 같이 점화식을 구할 때 1,000,000,007을 더한 상태로 연산해주어야 한다고 한다.

**나머지 연산**을 할 땐 **음수와 뺄셈**에 주의하자.
